<!doctype html>
<html>
  <head>
    <title>How to write a simple web crawler in Ruby - revisited - rossta.net</title>
<meta name="description" content="Bringing a fresh perspective and Ruby's Enumerator to revisit an old post on using Ruby to write a simple web crawler" />
<meta name="keywords" content="Code, Ruby" />
<meta name="site" content="rossta.net" />
<meta property="og:site_name" content="rossta.net" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="Ross Kaffenberger" />
<meta name="twitter:description" content="Bringing a fresh perspective and Ruby's Enumerator to revisit an old post on using Ruby to write a simple web crawler" />
<meta name="twitter:image:src" content="https://rossta.net/assets/images/blog/stock/spider-web-pexels-photo.jpg" />
<meta name="twitter:title" content="How to write a simple web crawler in Ruby - revisited" />
<meta property="og:description" content="Bringing a fresh perspective and Ruby's Enumerator to revisit an old post on using Ruby to write a simple web crawler" />
<meta property="og:image" content="https://rossta.net/assets/images/blog/stock/spider-web-pexels-photo.jpg" />
<meta property="og:title" content="How to write a simple web crawler in Ruby - revisited" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <script type="text/javascript" src="//use.typekit.net/ned0mml.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link href="/assets/stylesheets/all-f7b17499.css" rel="stylesheet" />
    <script src="/assets/javascripts/head-0145479a.js"></script>
    <link href="/assets/images/favicon.ico" rel="icon" type="image/ico" />
  </head>
  <body id="application" class="typekit">
    <nav id="welcome-nav" class="top-bar" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a class="logo" href="/">rossta.net</a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#">Menu</a></li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li class="nav"><a href="/blog">blog</a></li>
      <li class="nav"><a href="/talks">talks</a></li>
      <li class="nav"><a href="/projects">projects</a></li>
      <li class="nav"><a href="/about">about</a></li>
      <li class="nav"><a href="/feed.xml">feed</a></li>
    </ul>
  </section>
</nav>

    <div class="row">
      <section id="main" role="main" class="large-12 small-12 columns">
          <section id="blog" class="margin-bottom double">
    <article class="post margin-bottom double">
      <header>
  <h2>
    How to write a simple web crawler in Ruby - revisited
      <br />
      <small>Crawling websites and streaming structured data with Ruby's Enumerator</small>
  </h2>
</header>


      <p><img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo.jpg?1456838868" /></p>

<p>Let&rsquo;s build a simple web crawler in Ruby. For inspiration, I&rsquo;d like to
to revisit <a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/">Alan Skorkin&rsquo;s How to Write a Simple Web Crawler in Ruby</a> and attempt to achieve something similar with a fresh perspective.</p>

<p>We&rsquo;ll adapt Skork&rsquo;s original goals and provide a few of our own:</p>

<blockquote>
<ul>
<li>must be able to crawl just a single domain</li>
<li>must be able to limit number of pages to crawl</li>
<li>the results should be represented as structured data so we don&rsquo;t have an incomprehensible soup of content</li>
<li>the results should be enumerable so we can have flexibility in how they&rsquo;re handled</li>
</ul>
</blockquote>

<aside class="callout panel">
<p>
  Caveats! Please keep in mind that there are, of course, <a href="http://webscraper.io/">many</a> <a href="http://scrapy.org/">resources</a> for
  using resilient, well-tested <a href="https://www.import.io/">crawlers</a> in a variety of languages. We have mere academic intentions
  here so we choose to ignore many important concerns, such as client-side rendering, parallelism, and handling failure, as a matter of convenience.
</p>
</aside>

<h3>Breaking it down</h3>

<p>For this exercise, we&rsquo;re going to crawl <a href="http://www.programmableweb.com/">Programmable Web</a> to extract data from their <a href="http://www.programmableweb.com/apis/directory">API directory</a>.</p>

<p>Rather than take the naive approach of grabbing all content from any page, we&rsquo;re going to build a webcrawler that emits
structured data. Traversing from the first page of the api directory, our
crawler will visit web pages like a nodes of a tree, collecting data and
additional urls along the way.</p>

<p>Imagine that the results of our web crawl as a nested collection of
hashes with meaningful key-value pairs.</p>

<pre><code class="ruby"># results
[
  {
    name: &quot;Google Maps&quot;,
    api_provider: &quot;https://google.com&quot;
    api_homepage: &quot;https://developers.google.com/maps/&quot;
    categories: [&quot;Mapping&quot;, &quot;Viewer&quot;],
    provider_formats: [&quot;JSON&quot;, &quot;KML&quot;, &quot;XML&quot;]
    ...
  },
  {
    name: &quot;Twitter&quot;,
    api_provider: &quot;https://twitter.com&quot;
    api_homepage: &quot;https://dev.twitter.com/rest/public&quot;
    categories: [&quot;Social&quot;, &quot;Blogging&quot;],
    provider_formats: [&quot;Atom&quot;, &quot;JSON&quot;, &quot;REST&quot;, &quot;RSS&quot;, &quot;XML&quot;]
    ...
  },
]
</code></pre>

<aside class="callout panel">
<p>
  When using a web crawler, be aware of the limitations described in the website&rsquo;s <a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard">robots.txt</a> file. In this post, we skip automated parsing and detection of <a href="http://www.programmableweb.com/robots.txt">Programmable Web&rsquo;s robots.txt</a> to filter out blacklisted urls and set a crawl delay dynamically. If you choose to run this code on your own, please crawl responsibly.
</p>
</aside>

<h3>Designing the surface</h3>

<p>If you&rsquo;ve been following my posts lately, you know that <a href="https://rossta.net/blog/ruby-enumerable.html">I love Enumerable</a> and you may not be surprised that I&rsquo;d like to model our structured, website data with an <a href="/blog/what-is-enumerator.html">Enumerator</a>. This will provide a familiar, flexible interface that can be adapted for logging, storage, transformation, and a wide range of use cases.</p>

<p>I want to simply ask a <code>spider</code> object for its results and get back an enumerator:</p>

<pre><code class="ruby">spider.results
=&gt; #&lt;Enumerator: ...&gt;
</code></pre>

<p>We&rsquo;ll be able to do some interesting things, like stream the
results lazily into a flexible storage engine, e.g. <a href="https://www.mongodb.org/">mongodb</a> or <code>PStore</code>,
available from the <a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/pstore/rdoc/PStore.html">Ruby standard library</a>:</p>

<pre><code class="ruby">require &quot;pstore&quot;
store  = PStore.new(&quot;api_directory.pstore&quot;)

# create `spider`, then ...

spider.results.lazy.take(50).each_with_index do |result, i|
  store.transaction do
    store[result[:name]] = result
    store.commit
  end
end
</code></pre>

<h3>Writing the crawler</h3>

<p>We&rsquo;re going to write a <code>Spider</code> class to enumerate website data. Our spider implementation borrows heavily from <a href="https://github.com/joeyAghion/spidey">joeyAghion&rsquo;s spidey</a> gem, described as a &ldquo;loose framework for crawling and scraping websites&rdquo; and Python&rsquo;s venerable <a href="http://scrapy.org/">Scrapy</a> project, which allows you to scrape websites &ldquo;in a fast, simple, yet extensible way.&rdquo; Both resources achieve the goals of being easy-to-use and extensible.</p>

<p>We&rsquo;ll build our web crawler piece-by-piece, but if you want a full preview of the source, check out it <a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb">on GitHub</a>.</p>

<p>Our <code>Spider</code> will maintain a set of urls to visit, data is collects, and a set of url &ldquo;handlers&rdquo; that will describe how each page should be processed. We&rsquo;ll take advantage of one external dependency, <code>mechanize</code>, to handle interaction with the pages we visit - to extract data, resolve urls, follow redirects, etc. Below is the <code>#enqueue</code> method to add urls and their handlers to a running list in our spider.</p>

<pre><code class="ruby">require &quot;mechanize&quot; # as of this writing, the latest release is 2.7.4

class Spider
  def enqueue(url, method)
    url = agent.resolve(url).to_s
    return if @handlers[url]
    @urls &lt;&lt; url
    @handlers[url] ||= { method: method, data: {} }
  end

  private

  def agent
    @agent ||= Mechanize.new
  end
end
</code></pre>

<p>As we process each page we&rsquo;ll need a way to record the structured data we extract from various pages. We&rsquo;ll expose a <code>#record</code> method append a hash of data to the <code>@results</code> array.</p>

<pre><code class="ruby">class Spider
  def record(data = {})
    @results &lt;&lt; data
  end
end
</code></pre>

<p>Since our <code>Spider</code> will only know how to enumerate urls and record data, we&rsquo;ll introduce a collaborator object to contain the implementation for consuming data for a specific site. For now, we&rsquo;ll call this object a &ldquo;processor&rdquo;. The processor will respond to the messages <code>#root</code> and <code>#handler</code> - the first url and handler method to enqueue for the spider, respectively. We&rsquo;ll also provide options for enforcing limits on the number of pages to crawl and the delay between each request.</p>

<pre><code class="ruby">class Spider
  REQUEST_INTERVAL = 5
  MAX_URLS = 1000

  def initialize(processor, attrs = {})
    @processor = processor

    @urls     = []
    @results  = []
    @handlers = {}

    @interval = attrs.fetch(:interval, REQUEST_INTERVAL)
    @max_urls = attrs.fetch(:max_urls, MAX_URLS)

    enqueue(processor.root, processor.handler)
  end
end
</code></pre>

<h3>Enumerator Two Ways</h3>

<p>Now for the real meat of our young <code>Spider</code>. The <code>#results</code> method is the key public interface: it enumerates the enqueued urls and yields members of the <code>@results</code> collection.</p>

<pre><code class="ruby">class Spider
  def results
    return enum_for(:results) unless block_given?

    index = @results.length
    enqueued_urls.each do |url, handler|

      # process url
      @processor.send(handler[:method], agent.get(url), handler[:data])

      if block_given? &amp;&amp; @results.length &gt; index
        yield @results.last
        index += 1
      end

      # crawl delay
      sleep @interval if @interval &gt; 0
    end
  end

  private

  def enqueued_urls
    Enumerator.new do |y|
      index = 0
      while index &lt; @urls.count &amp;&amp; index &lt;= @max_urls
        url = @urls[index]
        index += 1
        next unless url
        y.yield url, @handlers[url]
      end
    end
  end
end
</code></pre>

<p>An interesting thing to note is that the size of our url queue and the collected results may be growing as we crawl more pages. For the <code>#enqueued_urls</code> private method, we&rsquo;re using an <code>Enumerator</code> to wrap the logic for iterating over the list of <code>@urls</code> and maintaining state, like the <code>index</code>. The <code>Enumerator</code> class is well-suited to represent a lazily generated collection.</p>

<pre><code class="ruby">def enqueued_urls
  Enumerator.new do |y|
    # ...
  end
end
</code></pre>

<p>I find it to be a more expressive way to indicate we&rsquo;re enumerating values &ldquo;on demand&rdquo; as opposed to &ldquo;eagerly&rdquo;, like a typical collection.</p>

<p>Notice we&rsquo;re also returning an enumerator from <code>#results</code>:</p>

<pre><code class="ruby">def results
  return enum_for(:results) unless block_given?
  # ...
end
</code></pre>

<p>This technique provides the method caller to more flexibility when determining
how to handler the results. While you could pass a block to consume the
results, e.g., <code>spider.results { |r| puts r.inspect }</code>, this is an eager
operation. We&rsquo;d have to wait for all the pages to be processed before continuing
with the block. Returning an enumerator offers the potential to stream results
to something like a data store.</p>

<p>Why not include <code>Enumerable</code> in our <code>Spider</code> and implement <code>#each</code> instead? As pointed out in <a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/">Arkency&rsquo;s Stop including Enumerable, return Enumerator
instead</a>, our
<code>Spider</code> class doesn&rsquo;t itself represent a collection, so exposing the <code>#results</code>
method as an enumerator is more appropriate.</p>

<h3>From Soup to Net Results</h3>

<p>Our <code>Spider</code> is now functional so we can move onto the details of extracting data from an actual website.</p>

<p>Our processor, <code>ProgrammableWeb</code> will be responsible for wrappin a <code>Spider</code> instance and extracting data from
the pages it visits. As mentioned previously, our processor will need to
define a root url and initial handler method, for which defaults are provided, and delegate the <code>#results</code> method to a <code>Spider</code> instance:</p>

<pre><code class="ruby">class ProgrammableWeb
  attr_reader :root, :handler

  def initialize(root: &quot;https://www.programmableweb.com/apis/directory&quot;, handler: :process_index, **options)
    @root = root
    @handler = handler
    @options = options
  end

  def results(&amp;block)
    spider.results(&amp;block)
  end

  private

  def spider
    @spider ||= Spider.new(self, @options)
  end
end
</code></pre>

<p><code>ProgrammableWeb</code> will define handler methods that deserialize a web page into additional urls and data to add to our collection of results.
Our spider will invoke the handlers (as seen above with <code>@processor.send(method, agent.get(url), data)</code>). Each handler method will have the following signature</p>

<pre><code class="ruby">def handler_method(page, data = {})
  # enqueue urls and/or record data
end
</code></pre>

<p>&hellip; where <code>page</code> is an instance of <code>Mechanize::Page</code> (<a href="http://docs.seattlerb.org/mechanize/Mechanize/Page.html">docs</a>) providing a number of methods for interacting with html content:</p>

<p>The root handler method, <code>ProgrammableWeb#process_index</code>, will extract api names in the
index list, enqueue api detail pages and additional, paginated indexes. As data
is collected, it may be passed on to handlers further down the tree via
<code>Spider#enqueue</code>.</p>

<pre><code class="ruby">def process_index(page, data = {})
  page.links_with(href: %r{\?page=\d+}).each do |link|
    spider.enqueue(link.href, :process_index)
  end

  page.links_with(href: %r{/api/\w+$}).each do |link|
    spider.enqueue(link.href, :process_api, name: link.text)
  end
end
</code></pre>

<p>To process api detail pages, we&rsquo;ll define a separate handler. Since these pages
will represent &ldquo;leaves&rdquo; in this exercise, we&rsquo;ll merge the data passed in with
that extracted from the page and pass it along to <code>Spider#record</code>.</p>

<pre><code class="ruby">def process_api(page, data = {})
  fields = page.search(&quot;#tabs-content .field&quot;).each_with_object({}) do |tag, o|
    key = tag.search(&quot;label&quot;).text.strip.downcase.gsub(%r{[^\w]+}, &#39; &#39;).gsub(%r{\s+}, &quot;_&quot;).to_sym
    val = tag.search(&quot;span&quot;).text
    o[key] = val
  end

  categories = page.search(&quot;article.node-api .tags&quot;).first.text.strip.split(/\s+/)

  spider.record data.merge(fields).merge(categories: categories)
end
</code></pre>

<p>As we saw earlier, recorded data is emitted in the <code>Spider#results</code> method.</p>

<p>Now we can make use of our <code>ProgrammableWeb</code> crawler as intended with simple
instantiation and the ability to enumerate results as a stream of data:</p>

<pre><code class="ruby">spider = ProgrammableWeb.new

spider.results.lazy.take(5).each_with_index do |result, i|
  puts &quot;%-3s: %s&quot; % [i, result.inspect]
end

# 0 : {:name=&gt;&quot;Facebook&quot;, :api_provider=&gt;&quot;http://facebook.com&quot;, :api_endpoint=&gt;&quot;http://api.facebook.com/restserver.php&quot;, :api_homepage=&gt;&quot;https://developers.facebook.com/&quot;, :primary_category=&gt;&quot;Social&quot;, :secondary_categories=&gt;&quot;Webhooks&quot;, :protocol_formats=&gt;&quot;JSON, REST&quot;, :ssl_support=&gt;&quot;Yes&quot;, :api_kits=&gt;&quot;http://developers.facebook.com/documentation.php?doc=clients&quot;, :api_forum=&gt;&quot;http://forum.developers.facebook.com/&quot;, :twitter_url=&gt;&quot;http://twitter.com/fbplatform&quot;, :developer_support=&gt;&quot;http://developers.facebook.com/group.php?gid=2205007948&quot;, :console_url=&gt;&quot;http://developers.facebook.com/tools/explorer&quot;, :authentication_mode=&gt;&quot;API Key, OAuth 2, Username/password&quot;, :categories=&gt;[&quot;Social&quot;, &quot;Webhooks&quot;]}
# 1 : {:name=&gt;&quot;LinkedIn&quot;, :api_provider=&gt;&quot;http://www.linkedin.com/&quot;, :api_endpoint=&gt;&quot;http://api.linkedin.com/v1/&quot;, :api_homepage=&gt;&quot;https://developer.linkedin.com/docs&quot;, :primary_category=&gt;&quot;Social&quot;, :secondary_categories=&gt;&quot;Enterprise&quot;, :protocol_formats=&gt;&quot;JSON, JSONP, REST, XML&quot;, :other_options=&gt;&quot;JavaScript&quot;, :ssl_support=&gt;&quot;Yes&quot;, :api_forum=&gt;&quot;https://developer.linkedin.com/forum&quot;, :twitter_url=&gt;&quot;https://twitter.com/linkedindev&quot;, :console_url=&gt;&quot;http://developer.linkedinlabs.com/jsapi-console/#examples/login/simple.html&amp;{&amp;quot;framework&amp;quot;:&amp;quot;platform.linkedin.com/in.js&amp;quot;,&amp;quot;frameworkurl&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;apikey&amp;quot;:&amp;quo&quot;, :authentication_mode=&gt;&quot;OAuth 2&quot;, :categories=&gt;[&quot;Social&quot;, &quot;Enterprise&quot;]}
# 2 : {:name=&gt;&quot;Skype&quot;, :api_provider=&gt;&quot;http://skype.com&quot;, :api_endpoint=&gt;&quot;http://skype.com&quot;, :api_homepage=&gt;&quot;http://www.skype.com/en/developer/&quot;, :primary_category=&gt;&quot;Telephony&quot;, :secondary_categories=&gt;&quot;Chat, Messaging, Video, Voice&quot;, :protocol_formats=&gt;&quot;Unspecified&quot;, :other_options=&gt;&quot;Skype proprietary&quot;, :ssl_support=&gt;&quot;Yes&quot;, :api_kits=&gt;&quot;https://developer.skype.com/Docs/Web https://developer.skype.com/wiki/Java_API&quot;, :api_forum=&gt;&quot;http://forum.skype.com/index.php?showforum=16&quot;, :developer_support=&gt;&quot;http://forum.skype.com/index.php?showforum=16&quot;, :authentication_mode=&gt;&quot;Unspecified&quot;, :categories=&gt;[&quot;Telephony&quot;, &quot;Chat,&quot;, &quot;Messaging,&quot;, &quot;Video,&quot;, &quot;Voice&quot;]}
# 3 : {:name=&gt;&quot;Twitter&quot;, :api_provider=&gt;&quot;http://twitter.com&quot;, :api_endpoint=&gt;&quot;http://twitter.com/statuses/&quot;, :api_homepage=&gt;&quot;https://dev.twitter.com/rest/public&quot;, :primary_category=&gt;&quot;Social&quot;, :secondary_categories=&gt;&quot;Blogging&quot;, :protocol_formats=&gt;&quot;Atom, JSON, REST, RSS, XML&quot;, :ssl_support=&gt;&quot;No&quot;, :api_kits=&gt;&quot;ActionScript&quot;, :api_forum=&gt;&quot;http://groups.google.com/group/twitter-development-talk&quot;, :twitter_url=&gt;&quot;http://twitter.com/twitterapi&quot;, :contact_email=&gt;&quot;api@twitter.com&quot;, :console_url=&gt;&quot;https://dev.twitter.com/console&quot;, :authentication_mode=&gt;&quot;OAuth 2, HTTP Basic Auth, OAuth&quot;, :categories=&gt;[&quot;Social&quot;, &quot;Blogging&quot;]}
# 4 : {:name=&gt;&quot;YouTube&quot;, :api_provider=&gt;&quot;http://www.google.com&quot;, :api_endpoint=&gt;&quot;http://gdata.youtube.com/feeds/&quot;, :api_homepage=&gt;&quot;https://developers.google.com/youtube/&quot;, :primary_category=&gt;&quot;Video&quot;, :secondary_categories=&gt;&quot;Media&quot;, :protocol_formats=&gt;&quot;Atom, RSS, JSON, XML, GData&quot;, :other_options=&gt;&quot;Atom Publishing Protocol (Atom/RSS)&quot;, :ssl_support=&gt;&quot;No&quot;, :api_kits=&gt;&quot;Java, PHP Python, Ruby, ActionScript&quot;, :api_forum=&gt;&quot;http://groups.google.com/group/youtube-api/&quot;, :twitter_url=&gt;&quot;https://twitter.com/YouTubeDev/&quot;, :developer_support=&gt;&quot;http://code.google.com/support/bin/topic.py?topic=12357&quot;, :console_url=&gt;&quot;http://code.google.com/apis/ajax/playground/?exp=youtube#simple_embed&quot;, :authentication_mode=&gt;&quot;OAuth2&quot;, :categories=&gt;[&quot;Video&quot;, &quot;Media&quot;]}
</code></pre>

<h3>Wrapping up</h3>

<p>I admit, it&rsquo;s arguable that this implementation is &ldquo;simple&rdquo;. Skorks provided a straightforward, recursive solution to consume unstructured content. Our approach is iterative and requires some work up front to define which links to consume and how to process them with &ldquo;handlers&rdquo;. However, we were able to achieve an extensible, flexible tool with a nice separation of concerns and a familiar, enumerable interface.</p>

<p>Modeling results from a multi-level page crawl as a collection may not work for every use case, but, for this exercise, it serves as a nice abstraction. It would now be trivial to take our <code>Spider</code> class and implement a new processor for a site like <a href="https://rubygems.org">rubygems.org</a> or <a href="https://craigslist.org">craigslist</a> and stream the results to a database like <a href="http://redis.io">Redis</a> or <a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html"><code>YAML::Store</code></a>.</p>

<p>Try it yourself and let me know what you think of this approach (<a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb">full source</a>).</p>


    </article>
    <hr />
    <section class="margin-bottom double">
      <p>
        If you liked this post, <a target="_blank" href="https://twitter.com/intent/tweet?text=How%20to%20write%20a%20simple%20web%20crawler%20in%20Ruby%20-%20revisited%20-%20rossta.net&amp;url=https%3A%2F%2Frossta.net%2Fblog%2Fhow-to-write-a-simple-web-crawler-in-ruby-revisited.html">share it on Twitter</a>
        and <a href="https://twitter.com/rossta">follow me</a>.
      </p>
      <p>
          This post is part of the <a href="/blog/series/enumerable.html">Enumerable</a> series.
        Published on Jan 27, 2016
      </p>
    </section>
  </section>
  <section class="share margin-bottom double">
  </section>
  <section class="signup-form standalone margin-bottom double">
    <!-- Begin MailChimp Signup Form -->
<div class="signup-form">
  <h3>Stop Wrangling with Rails</h3>
  <p>Sign up for my occasional newsletter on professional Ruby and Javascript for the web.</p>
  <div id="mc_embed_signup">
    <form action="//rossta.us6.list-manage.com/subscribe/post?u=8ce159842b5c98cecb4ebdf16&amp;id=96030b0bda" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <div id="mc_embed_signup_scroll">

        <div class="row">
          <div class="large-10 columns">
            <div class="row collapse">
              <div class="large-8 small-7 columns">
                <input type="email" placeholder="Your email..." value="" name="EMAIL" class="required email" id="mce-EMAIL">
              </div>
              <div class="large-4 small-5 columns">
                <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button postfix">
              </div>
            </div>
          </div>
        </div>

        <div id="mce-responses" class="clear">
          <div class="response" id="mce-error-response" style="display:none"></div>
          <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;"><input type="text" name="b_8ce159842b5c98cecb4ebdf16_96030b0bda" tabindex="-1" value=""></div>
      </div>
    </form>
  </div>

  <!--End mc_embed_signup-->
</div>

  </section>
    <hr />
    <section class="comments">
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname  = "rosskaff";
    var disqus_identifier = "how-to-write-a-simple-web-crawler-in-ruby-revisited";
    var disqus_title      = "How to write a simple web crawler in Ruby - revisited";
    var disqus_url        = "https://rossta.net/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html";

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<!-- <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->

    </section>

      </section>
    </div>
    
    <div class="row">
      <footer>
        <section class="large-12 columns center-inline-list">
          <ul class="inline-list">
  <li><a href="mailto:ross@rossta.net">email</a></li>
  <li><a href="https://twitter.com/rossta">twitter</a></li>
  <li><a href="https://github.com/rossta">github</a></li>
  <li><a href="https://stackoverflow.com/users/771838/rossta?tab=profile">stackoverflow</a></li>
  <li><a href="https://www.linkedin.com/in/rosskaffenberger">linkedin</a></li>
</ul>

        </section>
      </footer>
    </div>
    <script src="/assets/javascripts/all-fcc9857c.js"></script>
    
    <script type="text/javascript">
!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
analytics.load("NdBtrprkAGAjQryMShljRdVf90saElAU");
analytics.page()
}}();
if($&&$.tracking){var traits=$.tracking.traits,events=$.tracking.events;analytics.identify(traits),Object.keys(events).forEach(function(t,a){analytics.track(t,events[t])})}else analytics.identify();
</script>

  </body>
</html>
