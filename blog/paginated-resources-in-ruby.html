<!doctype html>
<html>
  <head>
    <title>Handling Paginated Resources in Ruby - rossta.net</title>
<meta name="description" content="Extracting data from an API can get messy once pagination is involved. We'll look at a few ways of dealing with this complexity, including &quot;recursive each&quot; and Kernel#to_enum method to enumerate pa..." />
<meta name="keywords" content="Code, Ruby" />
<meta name="site" content="rossta.net" />
<meta property="og:site_name" content="rossta.net" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="Ross Kaffenberger" />
<meta name="twitter:description" content="Extracting data from an API can get messy once pagination is involved. We'll look at a few ways of dealing with this complexity, including &quot;recursive each&quot; and Kernel#to_enum method to enumerate paginated resources" />
<meta name="twitter:image:src" content="https://rossta.net/assets/images/blog/stock/open-book-pexels-photo-8add5398.jpg" />
<meta name="twitter:title" content="Handling Paginated Resources in Ruby" />
<meta property="og:description" content="Extracting data from an API can get messy once pagination is involved. We'll look at a few ways of dealing with this complexity, including &quot;recursive each&quot; and Kernel#to_enum method to enumerate paginated resources" />
<meta property="og:image" content="https://rossta.net/assets/images/blog/stock/open-book-pexels-photo-8add5398.jpg" />
<meta property="og:title" content="Handling Paginated Resources in Ruby" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <script type="text/javascript" src="//use.typekit.net/ned0mml.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    <link href="/assets/stylesheets/index.bundle-4e801f2e.css" rel="stylesheet" />
    <script src="/assets/javascripts/head.bundle-ae1a9d85.js"></script>
    <link href="/assets/images/favicon.ico" rel="icon" type="image/ico" />
  </head>
  <body id="application" class="typekit">
    <nav id="welcome-nav" class="top-bar" data-topbar>
  <ul class="title-area">
    <li class="name">
      <h1><a class="logo" href="/">rossta.net</a></h1>
    </li>
    <li class="toggle-topbar menu-icon"><a href="#">Menu</a></li>
  </ul>

  <section class="top-bar-section">
    <ul class="left">
      <li class="nav"><a href="/blog">blog</a></li>
      <li class="nav"><a href="/talks">talks</a></li>
      <li class="nav"><a href="/projects">projects</a></li>
      <li class="nav"><a href="/about">about</a></li>
      <li class="nav"><a href="/feed.xml">feed</a></li>
    </ul>
  </section>
</nav>

    <div class="row">
      <section id="main" role="main" class="large-12 small-12 columns">
          <section id="blog" class="margin-bottom double">
    <article class="post margin-bottom double">
      <header class="page-header with-summary">
  <h2>
    Handling Paginated Resources in Ruby
  </h2>
    <h3>
      Wrap your paginated collections in Enumerable goodness
    </h3>
</header>

        <p><img src="/assets/images/blog/stock/open-book-pexels-photo-8add5398.jpg" /></p>

      <p>The thing with paginated data is we can&rsquo;t get it all at once.</p>

<p>Let&rsquo;s say we&rsquo;re using the <a href="https://developers.trello.com/">Trello API</a>. There are a number of Trello endpoints that return paginated data sets, such as boards, lists,
cards, and actions (like comments, copies, moves, etc).</p>

<p>If we&rsquo;re querying for Trello cards marked as completed each month since last January, for example, we may need to request several pages of &ldquo;cards&rdquo; <img src="/assets/images/icons/noun_63447-2fa20b1a.png" class="icon-image inline" /> <img src="/assets/images/icons/noun_63453-5cc436ec.png" class="icon-image inline" /></p>

<p>In most cases, Trello will provide a default limit, typically 50, on the number of resources returned in a single request. But what if you need more than that? In this post, we&rsquo;ll examine a few ways to collect paginated results in Ruby.</p>

<h3>Trello World</h3>

<p>The <a href="https://developers.trello.com/">Trello developer docs</a> provide a quickstart in javascript - here&rsquo;s the unofficial Ruby version.</p>

<p>While logged into your Trello account (you&rsquo;ll need one first), <strong><a href="https://trello.com/app-key">retrieve your app key</a></strong>. We won&rsquo;t need the &ldquo;secret&rdquo; for this article.</p>

<p>Next, you&rsquo;ll generate an <strong>app token</strong>. Paste the following URL into your browser with your app <strong>key</strong> subsituted for the placeholder.</p>

<pre><code class="bash">https://trello.com/1/authorize?expiration=never&amp;scope=read,write,account&amp;response_type=token&amp;name=Trello%20World&amp;key=YOUR_KEY
</code></pre>

<p>Now that we have an app key and token, we can make authenticated requests to the Trello API. As a quick test, paste the following url  with your own key and token as pararameters into your web browser (or use <code>curl</code>) to read your member data.</p>

<pre><code class="bash">https://api.trello.com/1/members/me?key=YOUR_KEY&amp;token=YOUR_TOKEN
</code></pre>

<p>You should see a JSON response with attributes like your Trello id, username, bio, etc.</p>

<h3>Script mode</h3>

<p>Now let&rsquo;s fetch some paginated data in Ruby. For the following examples, we&rsquo;ll be using Ruby 2.2.</p>

<aside class="callout panel"><p>

For academic reasons, we&rsquo;re ignoring available Ruby clients for the Trello API like <strong><a href="https://github.com/jeremytregunna/ruby-trello">ruby-trello</a></strong>, a popular library which aims to provide some ActiveRecord-like abstractions over Trello resources, and <strong><a href="https://github.com/rossta/tacokit.rb">tacokit.rb</a></strong>, a client with different design goals including simplicity and flexibility, inspired by the ideas presented in this post and the GitHub API Ruby wrapper, <a href="https://github.com/octokit/octokit.rb">octokit.rb</a>, in aiming to be a &ldquo;flat API client&hellip; that requires little knowledge of REST&rdquo;.

</p></aside>

<p>To make HTTP requests, we&rsquo;ll also use the <a href="https://github.com/httprb/http">http.rb</a>, but feel free to subsitute with your HTTP client of choice. Install the gem yourself with <code>gem install http</code> or add it to your <code>Gemfile</code>:</p>

<pre><code># Gemfile

gem &quot;http&quot;
</code></pre>

<p>To make things easier for the remainder, add the key and token as environment variables in your shell. For Mac/Linux users, something like this will work:</p>

<pre><code class="bash"># command line
export TRELLO_APP_KEY=your-key
export TRELLO_APP_TOKEN=your-token
</code></pre>

<p>Now, let&rsquo;s run Ruby version of our Trello World test.</p>

<pre><code class="ruby"># trello_eager.rb
require &quot;http&quot;

def app_key
  ENV.fetch(&quot;TRELLO_APP_KEY&quot;)
end

def app_token
  ENV.fetch(&quot;TRELLO_APP_TOKEN&quot;)
end

url = &quot;https://api.trello.com/1/members/me?key=#{app_key}&amp;token=#{app_token}&quot;
puts HTTP.get(url).parse
</code></pre>

<p>If it worked correctly, you should see the same result we saw in your browser earlier.</p>

<p>Let&rsquo;s extract a few helpers to build the url. We&rsquo;ll use <code>Addressable::URI</code>, which is available as a dependency of the http.rb gem as of version <code>1.0.0.pre1</code> or otherwise may be installed as <code>gem install addressable</code> or <code>gem &quot;addressable&quot;</code> in your <code>Gemfile</code>:</p>

<pre><code class="ruby">require &quot;http&quot;
require &quot;addressable/uri&quot;

def app_key
  ENV.fetch(&quot;TRELLO_APP_KEY&quot;)
end

def app_token
  ENV.fetch(&quot;TRELLO_APP_TOKEN&quot;)
end

def trello_url(path, params = {})
  auth_params = { key: app_key, token: app_token }

  Addressable::URI.new({
    scheme: &quot;https&quot;,
    host: &quot;api.trello.com&quot;,
    path: File.join(&quot;1&quot;, path),
    query_values: auth_params.merge(params)
  })
end

def get(path)
  HTTP.get(trello_url(path)).parse
end
</code></pre>

<h3>Let&rsquo;s Paginate</h3>

<p>Now we&rsquo;ll add an alternative method to <code>#get</code> that can handle pagination.</p>

<pre><code class="ruby">MAX = 1000

def paginated_get(path, options = {})
  params  = options.dup
  before  = nil
  max     = params.delete(:max) { 1000 }
  limit   = params.delete(:limit) { 50 }
  results = []

  loop do
    data = get(path, { before: before, limit: limit }.merge(params))

    results += data

    break if (data.empty? || results.length &gt;= max)

    before = data.last[&quot;id&quot;]
  end

  results
end
</code></pre>

<p>Given a path and hash of parameter options, we&rsquo;ll build up an array of results by fetching the endpoint and requesting the next set of 50 before the last id of the previos set. Once either the max is reached or no more results are returned from the API, we&rsquo;ll exit the loop.</p>

<p>As a starting point, this works nicely. We can simply use <code>paginated_get</code> to collect up to 1000 results for a given resource without the caller caring about pages. Here&rsquo;s how we can grab the all the comments we&rsquo;ve added to Trello cards:</p>

<pre><code class="ruby">def comments(params = {})
  paginated_get(&quot;members/me/actions&quot;, filter: &quot;commentCard&quot;)
end

comments
#=&gt; [{&quot;id&quot;=&gt;&quot;abcd&quot;, &quot;idMemberCreator&quot;=&gt;&quot;wxyz&quot;, &quot;data&quot;=&gt; {...} ...}, ...]
</code></pre>

<p>The main problem with this approach is that it forces the results to be eager loaded. Unless a max is specified in the method call, we could be waiting for up to 1000 comments to load - 20 requests of 50 comments each - to execute before the results are returned.</p>

<h3>Stop, enumerate, and listen</h3>

<p>Next step is to refactor our <code>paginated_get</code> method to take advantage of Ruby&rsquo;s <code>Enumerator</code>. I previously <a href="/blog/what-is-enumerator.html">described Enumerator</a> and showed how it can be used to <a href="/blog/infinite-sequences-in-ruby.html">generate infinite sequences in Ruby</a>, including <a href="/blog/pascals-triangle-with-rubys-enumerator.html">Pascal&rsquo;s Triangle</a>.</p>

<p>The main advantage of using <code>Enumerator</code> will be to give callers flexibility to work with the results including filtering, searching, and lazy enumeration.</p>

<pre><code class="ruby"># trello_enumerator.rb

def paginated_get(path, options = {})
  Enumerator.new do |y|
    params  = options.dup
    before  = nil
    total   = 0
    limit   = params.delete(:limit) { 50 }

    loop do
      data = get(path, { before: before, limit: limit }.merge(params))
      total += data.length

      data.each do |element|
        y.yield element
      end

      break if (data.empty? || total &gt;= MAX)

      before = data.last[&quot;id&quot;]
    end
  end
end
</code></pre>

<p>We&rsquo;ve got a few similarities with our first implementation. We still loop over repeated requests for successive pages until either the max is reach or no data is returned from the API. There are a few big differences though.</p>

<p>First, you&rsquo;ll notice we&rsquo;ve wrapped our expression in <code>Enumerator</code> which will serve as the return value for <code>#paginated_get</code>.</p>

<p>Using an enumerator may look strange but it offers a huge advantage over our first iteration. Enumerators allow callers to interact with data <strong>as it is generated</strong>. Conceptually, the enumerator represents the algorithm for retrieving or generating data in <code>Enumerable</code> form.</p>

<p>An enumerator implements the <code>Enumerable</code> module which means we can call familiar methods like <code>#map</code>, <code>#select</code>, <code>#take</code>, and so on.</p>

<p>Instead of building up an internal array of results, enumerators provide a mechanism for yielding each element even though a block may not be given to the method (how mind blowing is that?).</p>

<p>Now we can use enumerator chains to doing something like the following, where we request comment data lazily, transform the API hash to comment text and select the first two addressed to a colleague.</p>

<pre><code class="ruby">comments.lazy.
  map { |a| a[&quot;data&quot;][&quot;text&quot;] }.
  select { |t| t.start_with?(&quot;@personIWorkWith&quot;) }.
  take(2).force
</code></pre>

<p>We may not need to load all 1000 results to because the enumerators chain is evaluated for each item as it is yielded. This technique provides the caller with a great deal of flexibility. Eager loading can be delayed or avoided altogther - a potential performance gain.</p>

<p>Here are magic lines from <code>#paginated_get</code>:</p>

<pre><code class="ruby">data.each do |element|
  y.yield element
end
</code></pre>

<p>The <code>y.yield</code> is not the keyword <code>yield</code>, but the invokation of the <code>#yield</code> method of <code>Enumerator::Yielder</code>, an object the enumerator uses internally to pass values through to the first block used in the enumerator chain. For a more detailed look at how enumerators work under the hood, read more about how <a href="http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy">Ruby works hard so you can be lazy</a>.</p>

<h3>A cursor-y example</h3>

<p>Let&rsquo;s do one more iteration on our <code>#paginated_get</code> refactoring. Up to this point, we&rsquo;ve been using a &ldquo;functional&rdquo; approach; we&rsquo;ve just been using a bunch of methods defined in the outermost lexical scope.</p>

<p>First, we&rsquo;ll extract a <code>Client</code> responsible for sending requests to the Trello API and parsing the responses as JSON.</p>

<pre><code class="ruby"># trello_client.rb

require &quot;http&quot;
require &quot;addressable/uri&quot;

class Client
  def initialize(opts = {})
    @app_key   = opts.fetch(:app_key, ENV.fetch(&quot;TRELLO_APP_KEY&quot;))
    @app_token = opts.fetch(:app_token, ENV.fetch(&quot;TRELLO_APP_TOKEN&quot;))
  end

  def get(path, params = {})
    HTTP.get(trello_url(path, params)).parse
  end

  private

  def trello_url(path, params = {})
    auth_params = { key: @app_key, token: @app_token }

    Addressable::URI.new({
      scheme: &quot;https&quot;,
      host: &quot;api.trello.com&quot;,
      path: File.join(&quot;1&quot;, path),
      query_values: auth_params.merge(params)
    })
  end
end
</code></pre>

<p>Next, we&rsquo;ll provide a class to represent the paginated collection of results to replace our implementation of <code>#paginated_get</code>.</p>

<p>The Twitter API uses <a href="https://dev.twitter.com/overview/api/cursoring">cursors</a> to navigate through pages, a concept similar to &ldquo;next&rdquo; and &ldquo;previous&rdquo; links on websites. Although Trello doesn&rsquo;t provide explicit cursors in their API, we can still wrap the paginated results in an enumerable class to get similar behavior.</p>

<pre><code class="ruby"># trello_cursor.rb
require_relative &quot;./trello_client&quot;

class Cursor
  def initialize(path, options = {})
    @path       = path
    @params     = params

    @collection = []
    @before     = params.fetch(:before, nil)
    @limit      = params.fetch(:limit, 50)
  end
end
</code></pre>

<p>The <code>Cursor</code> will be initialized with a path and params, like our <code>paginated_get</code>. We&rsquo;ll also maintain an internal <code>@collection</code> array to cache elements as they are returned from Trello.</p>

<pre><code class="ruby">class Cursor
  private

  def client
    @client ||= Client.new
  end

  def fetch_next_page
    response              = client.get(@path, @params.merge(before: @before, limit: @limit))
    @last_response_empty  = response.empty?
    @collection           += response
    @before               = response.last[&quot;id&quot;] unless last?
  end

  MAX = 1000

  def last?
    @last_response_empty || @collection.size &gt;= MAX
  end
end
</code></pre>

<p>We&rsquo;ll introduce a dependency on the <code>Client</code> to interface with Trello through the private client method. We&rsquo;ll use our client to fetch the next page, append the latest results to our cached <code>@collection</code> and increment the page number. Now for the key public method:</p>

<pre><code class="ruby">class Cursor
  include Enumerable

  def each(start = 0)
    return to_enum(:each, start) unless block_given?

    Array(@collection[start..-1]).each do |element|
      yield(element)
    end

    unless last?
      start = [@collection.size, start].max

      fetch_next_page

      each(start, &amp;Proc.new)
    end
  end
end
</code></pre>

<p>We&rsquo;ve chosen to have our <code>Cursor</code> expose the Enumerable API by including the <code>Enumerable</code> module and implementing <code>#each</code>. This will give cursor instances enumerable behavior so we can simply replace our paginated_get definition to return a new <code>Cursor</code>.</p>

<pre><code class="ruby">def paginated_get(path, params)
  Cursor.new(path, param)
end

def comments(params = {})
  paginated_get(&quot;members/me/actions&quot;, filter: &quot;commentCard&quot;)
end
</code></pre>

<p>Let&rsquo;s break down <code>Cursor#each</code> a bit further. The first line allows us retain the <code>Enumerator</code> behavior before.</p>

<pre><code class="ruby">return to_enum(:each, start) unless block_given?
</code></pre>

<p>It invokes <code>Kernel#to_enum</code> when no block is given to an <code>each</code> method call. In this case, the method returns an <code>Enumerator</code> that packages the behavior of <code>#each</code> for an enumerator chain similar to before:</p>

<pre><code class="ruby">puts comments.each.lazy.
  map { |axn| axn[&quot;data&quot;][&quot;text&quot;] }.
  select { |txt| txt.start_with?(&quot;@mgerrior&quot;) }.
  take(2).force
</code></pre>

<p>For more info on using <code>#to_enum</code>, check out Arkency&rsquo;s <a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/">Stop including Enumerable, return Enumerator instead</a>.</p>

<p>We also need to <code>yield</code> each element in the <code>@collection</code> to pass elements to callers of <code>#each</code></p>

<pre><code class="ruby">Array(@collection[start..-1]).each do |element|
  yield(element)
end
</code></pre>

<p>We iterate from the start of the collection to the end with <code>Array(@collection[start..-1]).each</code>&hellip; but wait! when we start iterating, the <code>@collection</code> is empty:</p>

<pre><code class="ruby">def initialize
  # ...
  @collection = []
end
</code></pre>

<p>Wat?</p>

<p>The key comes in the lines that follow in <code>#each</code>:</p>

<pre><code class="ruby">unless last?
  start = [@collection.size, start].max

  fetch_next_page

  each(start, &amp;Proc.new)
end
</code></pre>

<p>Unless we&rsquo;ve encountered the last page, we fetch the next page, which appends the latest results to the collection and we recursively invoke <code>#each</code> with a starting point. This means <code>#each</code> will be invoked again with new results until no new data is encountered. Sweet!</p>

<p>A neat trick is how we forward the block given to <code>#each</code>. When we <code>Proc.new</code> without explicitly passing a block or proc object, it will instantiate with the block given to its surrounding method if there is one. The behavior is similar to the following:</p>

<pre><code class="ruby">def each(start = 0, &amp;block)
  # ...
  each(start, &amp;block)
  # ...
end
</code></pre>

<p>The main benefit being we don&rsquo;t needlessly invoke <code>Proc.new</code> by omitting <code>&amp;block</code> in the arguments. For more on this, read up on <a href="http://mudge.name/2011/01/26/passing-blocks-in-ruby-without-block.html">Passing Blocks in Ruby without &amp;block</a></p>

<p>&ldquo;Recursive each&rdquo; is a powerful technique for providing a seamless, enumerable interface to paginated or cursored results. I first encountered <a href="https://github.com/sferik/twitter/blob/c6c2fe44e4a56c3e3544a3c08492a8b83b549635/lib/twitter/enumerable.rb">this approach</a> in the <a href="https://github.com/sferik">sferik&rsquo;s</a> <a href="https://github.com/sferik/twitter">Twitter gem</a> - a great resource for those considering writing an API wrapper in Ruby.</p>

<h3>On your own</h3>

<p>Give it a shot! Pick out an API you like to use and play with techniques for modeling its collection resources. This is a great way to get more experience with Ruby&rsquo;s <a href="/blog/series/enumerable.html">Enumerable</a>. Consider one of these approaches when you need to traverse paginated or partitioned subsets of data in an external or internal API.</p>

<p>Think less about <strong>pages</strong> and more about <strong>data</strong>.</p>

<hr>

<p>Changelog</p>

<p>2016-01-28</p>

<ul>
<li>Updated the examples to use the <code>:before</code> parameter instead of <code>:page</code> for requests for successive &ldquo;pages&rdquo;</li>
<li>Posted the <a href="https://github.com/rossta/loves-enumerable/tree/master/examples/paginated_resources">full source of the examples above on GitHub</a></li>
</ul>

<hr>

<h3>Credits</h3>

<p>Icons via the <a href="https://thenounproject.com/">Noun Project</a>:</p>

<ul>
<li><a href="https://thenounproject.com/pixelbazaar/">Arrows by Zlatko Najdenovski</a></li>
</ul>


    </article>
    <hr />
    <section class="margin-bottom double">
      <p>
        If you liked this post, <a target="_blank" href="https://twitter.com/intent/tweet?text=Handling%20Paginated%20Resources%20in%20Ruby%20-%20rossta.net&amp;url=rossta.net%3A4567%2Fblog%2Fpaginated-resources-in-ruby.html">share it on Twitter</a>
        and <a href="https://twitter.com/rossta">follow me</a>.
      </p>
      <p>
          This post is part of the <a href="/blog/series/enumerable.html">Enumerable</a> series.
        Published on Dec 15, 2015
      </p>
    </section>
  </section>
  <section class="share margin-bottom double">
  </section>
  <section class="signup-form-standalone margin-bottom double">
    <!-- Begin MailChimp Signup Form -->
<div class="signup-form">
  <h3>Stop Wrangling with Rails</h3>
  <p>Sign up for my occasional newsletter on professional Ruby and Javascript for the web.</p>
  <div id="mc_embed_signup">
    <form action="//rossta.us6.list-manage.com/subscribe/post?u=8ce159842b5c98cecb4ebdf16&amp;id=96030b0bda" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <div id="mc_embed_signup_scroll">

        <div class="row">
          <div class="large-10 columns">
            <div class="row collapse">
              <div class="large-8 small-7 columns">
                <input type="email" placeholder="Your email..." value="" name="EMAIL" class="required email" id="mce-EMAIL">
              </div>
              <div class="large-4 small-5 columns">
                <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button postfix">
              </div>
            </div>
          </div>
        </div>

        <div id="mce-responses" class="clear">
          <div class="response" id="mce-error-response" style="display:none"></div>
          <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
        <div style="position: absolute; left: -5000px;"><input type="text" name="b_8ce159842b5c98cecb4ebdf16_96030b0bda" tabindex="-1" value=""></div>
      </div>
    </form>
  </div>

  <!--End mc_embed_signup-->
</div>

  </section>
    <hr />
    <section class="comments">
      <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname  = "rosskaff";
    var disqus_identifier = "paginated-resources-in-ruby";
    var disqus_title      = "Handling Paginated Resources in Ruby";
    var disqus_url        = "https://rossta.net/blog/paginated-resources-in-ruby.html";

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<!-- <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> -->

    </section>

      </section>
    </div>
    
    <div class="row">
      <footer>
        <section class="large-12 columns center-inline-list">
          <ul class="inline-list">
  <li><a href="mailto:ross@rossta.net">email</a></li>
  <li><a href="https://twitter.com/rossta">twitter</a></li>
  <li><a href="https://github.com/rossta">github</a></li>
  <li><a href="https://stackoverflow.com/users/771838/rossta?tab=profile">stackoverflow</a></li>
  <li><a href="https://www.linkedin.com/in/rosskaffenberger">linkedin</a></li>
</ul>

        </section>
      </footer>
    </div>
    <script src="/assets/javascripts/index.bundle-000158ba.js"></script>
    
    <script type="text/javascript">
!function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
analytics.load("NdBtrprkAGAjQryMShljRdVf90saElAU");
analytics.page()
window.$.tracking.flush(analytics);
}}();
</script>

  </body>
</html>
