<!doctype html>
<html class="antialiased" lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<title>Ancient City Ruby Snake Case - rossta.net</title>
<meta name="description" content="Comparing mathematical, iterative, and recursive solutions to the Snake Case challenge posed during the Ancient City Ruby Conference" />
<meta name="keywords" content="Ruby" />
<meta itemprop="name" content="Ancient City Ruby Snake Case" />
<meta itemprop="description" content="Comparing mathematical, iterative, and recursive solutions to the Snake Case challenge posed during the Ancient City Ruby Conference" />
<meta itemprop="image" content="https://rossta.net/assets/images/blog/stock/snakes-pexels-photo.jpg" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="rossta.net" />
<meta name="twitter:url" content="https://rossta.net/blog/ancient-city-snake-case.html" />
<meta name="twitter:title" content="Ancient City Ruby Snake Case" />
<meta name="twitter:description" content="Comparing mathematical, iterative, and recursive solutions to the Snake Case challenge posed during the Ancient City Ruby Conference" />
<meta name="twitter:image" content="https://rossta.net/assets/images/blog/stock/snakes-pexels-photo.jpg" />
<meta property="og:url" content="https://rossta.net/blog/ancient-city-snake-case.html" />
<meta property="og:type" content="website" />
<meta property="og:title" content="Ancient City Ruby Snake Case" />
<meta property="og:image" content="https://rossta.net/assets/images/blog/stock/snakes-pexels-photo.jpg" />
<meta property="og:description" content="Comparing mathematical, iterative, and recursive solutions to the Snake Case challenge posed during the Ancient City Ruby Conference" />
<meta property="og:site_name" content="rossta.net" />
<meta property="og:locale" content="en_US" />
<link rel="separator" href="-" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="mobile-web-app-capable" content="yes">

    <link rel="pingback" href="https://webmention.io/rossta.net/xmlrpc" />
    <link rel="webmention" href="https://webmention.io/rossta.net/webmention" />
    <link rel="canonical" href="https://rossta.net/blog/ancient-city-snake-case.html" />
    <script type="application/ld+json">
      {"@context":"https://schema.org","@type":"Article","publisher":{"@type":"Organization","name":"Ross Kaffenberger"},"author":{"@type":"Person","name":"Ross Kaffenberger","image":{"@type":"ImageObject","url":"https://rossta.net/assets/images/me.jpg","width":400,"height":400},"url":"https://rossta.net","sameAs":["https://rossta.net/about/","https://twitter.com/rossta"]},"headline":"Ancient City Ruby Snake Case","url":{"scheme":"https","user":null,"password":null,"host":"rossta.net","port":null,"path":"/blog/ancient-city-snake-case.html","query":null,"fragment":null},"datePublished":"2016-04-12T00:00:00Z","keywords":"ruby","description":"Comparing mathematical, iterative, and recursive solutions to the Snake Case challenge posed during the Ancient City Ruby Conference","mainEntityOfPage":{"@type":"WebPage","@id":"https://rossta.net"}}
    </script>


    <link rel="stylesheet" href="/css/app.f7bb33b95ea908b47d5f.css" media="all"></link>
    <script async defer data-domain="rossta.net" src="https://plausible.io/js/plausible.outbound-links.js"></script>
  </head>
  <body id="application" class="leading-relaxed">
    <header id="welcome-nav" class="top-bar text-gray-800 sm:flex sm:justify-between sm:items-center sm:px-4 sm:py-3" data-topbar>
  <div class="flex justify-between items-center px-4 py-3 sm:p-0">
    <h1 class="text-2xl font-bold">
      <a class="logo" href="/"><span>rossta.net</span></a>
    </h1>
    <button type="button" aria-label="Menu" class="top-bar-menu-button sm:hidden block text-gray-500 hover:text-gray-700 focus:text-gray-700 focus:outline-none">
      <svg class="h-6 w-6 fill-current" viewBox="0 0 24 24">
        <path class="icon" d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"/>
        <path class="icon hidden" d="M18.278 16.864a1 1 0 0 1-1.414 1.414l-4.829-4.828-4.828 4.828a1 1 0 0 1-1.414-1.414l4.828-4.829-4.828-4.828a1 1 0 0 1 1.414-1.414l4.829 4.828 4.828-4.828a1 1 0 1 1 1.414 1.414l-4.828 4.829 4.828 4.828z"/>
      </svg>
    </button>
  </div>
  <nav class="top-bar-section hidden sm:block sm:flex sm:justify-around px-2 pt-2 pb-4">
    <a class="block px-2 py-1 hover:bg-green-200 sm:mt-0 sm:ml-2 mt-1" href="/blog/">blog</a>
    <a class="block px-2 py-1 hover:bg-green-200 sm:mt-0 sm:ml-2 mt-1" href="/about/">about</a>
    <a class="block px-2 py-1 hover:bg-green-200 sm:mt-0 sm:ml-2 mt-1" href="/feed.xml">feed</a>
  </nav>
</header>

    <main id="main" role="main" class="layout container">
        <article class="post mb-12">
    <header class="page-header mt-4">
  <h1>
    Ancient City Ruby Snake Case
  </h1>
    <h2 class="mt-4 text-gray-600 font-medium">
      Comparing mathematical, iterative, and recursive solutions
    </h2>
</header>

    <p>Last week <a href="#">I spoke</a> at <a href="#">Ancient City Ruby Conference</a> where the organizers encouraged people to participate in a Ruby programming challenge called <a href="http://www.ancientcityruby.com/snake_case/" target="_blank" rel="noopener noreferrer">Snake Case</a>. I benchmarked a number of different ways to solve the challenge in Ruby and present the results here.</p>

<p>Here&#39;s the challenge:</p>

<blockquote>
<p>THE ANCIENT CITY RUBY 2016 PROGRAMMING CHALLENGE</p>

<p>You&#39;ve just arrived in sunny St. Augustine, and find yourself amazed by the visionary civic planning that would result in the area in which you now stand: a street grid exactly 10 blocks square.</p>

<p>You&#39;re in the northwest corner of this 10 by 10 block area, and would like to take a scenic walk to the southeast corner, while only ever moving south or east.</p>

<p>As you begin walking, you wonder to yourself, &quot;how many different paths could I take from this northwest corner to the southeast corner?&quot;</p>

<p>You quickly note that if the downtown area were only a 2 block by 2 block grid, there would be 6 distinct paths from one corner to the other:</p>
</blockquote>

<p><img src="/assets/images/blog/snake-case-blocks.png" alt="" loading="lazy" /></p>

<p>It&#39;s worth nothing that the intent of the problem was to calculate the correct
number of &quot;optimal&quot; paths along the blocks, so a meandering path does not count.
Starting at the northwest corner of a 10x10 grid, there will be 20 moves in
any valid path: 10 moves south and 10 moves east.</p>

      <h3 id="recursion" class="title title-h3">
        <a name="recursion" class="anchor" href="#recursion">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Recursion
      </h3>
    
<p>How about a recursive solution? Consider that for any location <code>h, w</code> on the grid, there are either one or two incoming paths oriented in the south or west direction, one coming from neighbor <code>h-1, w</code> and the other coming from neighbor <code>h, w-1</code>.</p>

<p>This means that the solution for the given location is the sum of two subproblems: the number of paths arriving at location <code>h-1, w</code> plus the number of paths arriving at location <code>h, w-1</code>. In pseudocode:</p>

<pre><code class="ruby">path_count(h, w) = path_count(h-1, w) + path_count(h, w-1)
</code></pre>

<p>The exception to this rule is if either <code>h</code> or <code>w</code> are on the &quot;edges&quot;, meaning the
value is 0. In this case, there&#39;s only 1 path that can reach these locations.</p>

<p>Now we have enough information to construct a recursive solution to the problem:</p>

<pre><code class="ruby"># recursive
def path_count(h, w)
  return 1 if h == 0 || w == 0

  path_count(h-1, w) + path_count(h, w-1)
end
</code></pre>

<p>The expected result for a 10x10 grid is <code>184,756</code>.</p>

<pre><code class="ruby">path_count(10, 10)
# =&gt; 184756
</code></pre>

<p>This works!  Let&#39;s consider some alternative approaches.</p>

      <h3 id="binary-and-binomial" class="title title-h3">
        <a name="binary-and-binomial" class="anchor" href="#binary-and-binomial">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Binary and Binomial
      </h3>
    
<p><a href="http://rayhightower.com/" target="_blank" rel="noopener noreferrer">Ray Hightower</a>, who also <a href="http://rayhightower.com/blog/2016/04/08/ancient-city-ruby-2016/" target="_blank" rel="noopener noreferrer">spoke at ACR</a>, recently published a nice writeup of a <a href="http://rayhightower.com/blog/2016/04/11/comparing-ruby-c-and-go/" target="_blank" rel="noopener noreferrer">&quot;brute force&quot; solution in Ruby, C, and Go</a>. Please check out his detailed explanation of both a mathematical and brute force solution in Ruby.</p>

<p>The mathematics approach is a factorial: given a 10x10 grid, we want to
construct 20 moves where 10 moves are &quot;south&quot; and 10 moves are &quot;east&quot;. We could
represent this conceptually as a bit map, where the total number of bits is
20^2, or <code>(h+w)**2</code> where <code>h</code> is the height and <code>w</code> is the width of the grid. It
turns out this can be represented as a <a href="https://en.wikipedia.org/wiki/Binomial_coefficient" target="_blank" rel="noopener noreferrer">binomial coefficient</a> often expressed as:</p>

<p><img src="/assets/images/blog/binomial-coefficient.gif" alt="" loading="lazy" /></p>

<p>Ray provided a nice LaTex-formatted description of the mathematics involved. Translated into a general Ruby function, this can be expressed in factorials.</p>

<pre><code class="ruby"># factorial
def path_count(h, w)
  (h+w).downto(h+1).reduce(:*) / w.downto(1).reduce(:*)
end
</code></pre>

<p>This function gives the correct solution for 10x10: <code>184,756</code>.</p>

<pre><code class="ruby">path_count(10, 10)
# =&gt; 184756
</code></pre>

<p>A &quot;brute-force&quot; solution counts up all the &quot;1&quot; bits in all possible combination
of bits from 0 to 2^(h+w), or 2^20 in our case of a 10x10 grid.</p>

<p>Expressed in a general Ruby function:</p>

<pre><code class="ruby"># brute force
def path_count(h, w)
  (0..(2**(h+w))).count { |x| x.to_s(2).chars.count(&quot;1&quot;) == n }
end
</code></pre>

<p>The total number of bits to explore is equal to <code>2**(h+w)</code>. We count how many of
those numbers, when expressed as binary with <code>x.to_s(2)</code> have 10 &quot;1&quot; bits.</p>

      <h3 id="iteration" class="title title-h3">
        <a name="iteration" class="anchor" href="#iteration">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Iteration
      </h3>
    
<p>The recursive solution asks us to solve the problem backwards in a way: given
the destination, figure out the solution by solving the problem for the nearest previous destinations and the ones that came before those and so on. What if we could &quot;build up&quot; to the solution instead? We can take an iterative approach in stead.</p>

<p>Imagine each corner or &quot;node&quot; of the grid can be represented as the number of paths leading to it. For a 5x5 grid, there are 6 nodes and each would have a value of <code>1</code>, since there is only one way to get to those nodes.</p>

<pre><code>1--1--1--1--1--1  # first row of a 5x5 grid
</code></pre>

<p>The second row gets interesting. Each node will be the sum of paths leading to
the nodes immediately north and west. So, the first node in the second row is
still just <code>1</code> since no paths lie to the west and the value of the node
immediately to the north is <code>1</code>. The second node in the second row gets a value
of <code>2</code> since the node to the west is now <code>1</code> and the node to the north is also <code>1</code>. Continuing on, this gives a second row of <code>1 2 3 4 5 6</code>:</p>

<pre><code>1--1--1--1--1--1
1--2--3--4--5--6
</code></pre>

<p>The third row:</p>

<pre><code>1--1--1--1--1--1
1--2--3--4--5--6
1--3--6--10-15-21
</code></pre>

<p>And so on... The number of paths for a given grid would simply be the value of
the last node in the last row. Let&#39;s implement this in Ruby:</p>

<pre><code class="ruby"># iterative
def path_count(h, w)
  row = [1] * (w+1) # first row of &quot;1s&quot;

  h.times do
    row = row.reduce([]) { |acc, p| acc &lt;&lt; (p + acc.last.to_i)  }
  end

  row.last
end
</code></pre>

<p>The <code>reduce</code> expression generates a row from the previous one and the values of
each previous member of the current row. The function returns the last member of
the last row.</p>

<p>Since <a href="/talks/ruby-enumerator.html">I gave a talk about Enumerator at Ancient City</a> I decided it would only
be appropriate if I solved the Snake Case challenge using an <code>Enumerator</code>. We
can extract an Enumerator from the iterative solution to represent a function that generates each row of the grid:</p>

<pre><code class="ruby">def grid(h, w)
  return to_enum(:grid, h, w) unless block_given?

  row = [1] * (w+1)
  yield row

  h.times do
    row = row.reduce([]) { |acc, p| acc &lt;&lt; (p + acc.last.to_i)  }
    yield row
  end
end
</code></pre>

<p>Two key changes have been made. We&#39;ve inserted <code>yield</code> statements to allow the
caller to receive each row of the grid as it is generated. We also  &quot;enumeratorize&quot; our iterative function by converting the behavior of the function into an <code>Enumerator</code> when no block is given in the first line.</p>

<p>Calling <code>grid(10, 10)</code> returns an <code>Enumerator</code>:</p>

<pre><code class="ruby">grid(10, 10)
# =&gt; #&lt;Enumerator: ...&gt;
</code></pre>

<p>Calling <code>to_a</code> on our <code>Enumerator</code> creates each &quot;node&quot; value:</p>

<pre><code class="ruby">grid(10, 10).to_a
# =&gt; [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
# [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66],
# [1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286],
# [1, 5, 15, 35, 70, 126, 210, 330, 495, 715, 1001],
# [1, 6, 21, 56, 126, 252, 462, 792, 1287, 2002, 3003],
# [1, 7, 28, 84, 210, 462, 924, 1716, 3003, 5005, 8008],
# [1, 8, 36, 120, 330, 792, 1716, 3432, 6435, 11440, 19448],
# [1, 9, 45, 165, 495, 1287, 3003, 6435, 12870, 24310, 43758],
# [1, 10, 55, 220, 715, 2002, 5005, 11440, 24310, 48620, 92378],
# [1, 11, 66, 286, 1001, 3003, 8008, 19448, 43758, 92378, 184756]]
</code></pre>

<p>Notice the last value of the last row is the correct answer to our path count
challenge.</p>

<p>For our revised <code>path_count</code> method, we simply want to retrieve the last member of the last row:</p>

<pre><code class="ruby"># enumeartive
def path_count(h, w)
  grid(h, w).drop(h-1).last.last
end
</code></pre>

<p>It&#39;s worth noting that the nodes of this grid follow the pattern of Pascal&#39;s
Triangle expanding from the northwest corner. Pascal&#39;s Triangle is well suited for an Enumerator function as <a href="/blog/pascals-triangle-with-rubys-enumerator.html">I&#39;ve written about previously</a>.</p>

      <h3 id="tradeoffs" class="title title-h3">
        <a name="tradeoffs" class="anchor" href="#tradeoffs">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        Tradeoffs
      </h3>
    
<p>We&#39;ve described a number of ways to solve Snake Case and each comes with
tradeoffs.</p>

<p>In terms of readability, I would personally place the solutions in the following
order from most to least readable:</p>

<ol>
<li>Recursive</li>
<li>Iterative</li>
<li>Brute force</li>
<li>Factorial</li>
</ol>

<p>At least for me, the recursive solution is the easiest to wrap my
head around and most readable result. It&#39;s easy to see from the recursive implementation how the problem may be divided into smaller sub-problems. The others require some deeper visualization and/or mathematical understanding to &quot;grok&quot; I feel. The factorial expression seems farthest removed conceptually from the description of the problem. In other words, it&#39;s most at odds with my intuition, but I&#39;m also not a mathematician so am less inclined to think in those terms.</p>

<p>How do they compare performance-wise? With <code>benchmark-ips</code> we can compare the
iterations/second and share the results.</p>

<p>Here&#39;s a file that defines each of the approaches we&#39;ve described in separate
modules and benchmarks the performance for calculating the result for a 10x10
grid. (<a href="https://github.com/rossta/loves-enumerable/blob/edbab0fcb2aeac65a7b34d9fa603b3aa58563b4f/code/snake_case.rb" target="_blank" rel="noopener noreferrer">Full source</a>)</p>

<p>Running on my mid-2014 MacBook Pro with MRI ruby-2.3:</p>

<pre><code class="ruby">require &quot;benchmark/ips&quot;

Benchmark.ips do |x|
  x.report(&quot;snake case factorial&quot;) do
    SnakeCase::Factorial.path_count(10, 10)
  end

  x.report(&quot;snake case brute force&quot;) do
    SnakeCase::Bruteforce.path_count(10, 10)
  end

  x.report(&quot;snake case recursive&quot;) do
    SnakeCase::Recursive.path_count(10, 10)
  end

  x.report(&quot;snake case iterative&quot;) do
    SnakeCase::Iterative.path_count(10, 10)
  end

  x.report(&quot;snake case enumerative&quot;) do
    SnakeCase::Enumerative.path_count(10, 10)
  end

  x.compare!
end

# $ SHARE=1 ruby code/snake_case.rb
# Calculating -------------------------------------
# snake case factorial    34.658k i/100ms
# snake case brute force
#                          1.000  i/100ms
# snake case recursive     5.000  i/100ms
# snake case iterative     4.920k i/100ms
# snake case enumerative
#                          4.109k i/100ms
# -------------------------------------------------
# snake case factorial    456.100k (± 7.8%) i/s -      2.287M
# snake case brute force
#                           0.325  (± 0.0%) i/s -      2.000  in   6.161730s
# snake case recursive     50.084  (±10.0%) i/s -    250.000
# snake case iterative     52.616k (± 5.3%) i/s -    265.680k
# snake case enumerative
#                          42.875k (± 7.1%) i/s -    213.668k
#
# Comparison:
# snake case factorial:   456100.0 i/s
# snake case iterative:    52615.9 i/s - 8.67x slower
# snake case enumerative:    42874.6 i/s - 10.64x slower
# snake case recursive:       50.1 i/s - 9106.72x slower
# snake case brute force:        0.3 i/s - 1405090.92x slower
#
# Shared at: https://benchmark.fyi/f
</code></pre>

<p>The factorial solution is orders of magnitude faster than the others. The iterative (and relatively similar enumerative) examples are only about ~10x slower than the factorial version while the recursive solution is almost 10,000x slower. The brute force solution is over a million-times slower. Even though the standard deviation in some of the results was fairly large, the differences across strategies appear conclusive.</p>

<p>The maintainer of <code>benchmark-ips</code>, <a href="https://twitter.com/evanphx" target="_blank" rel="noopener noreferrer">Evan Phoenix</a>, added the ability to share benchmark results online. You can see <a href="https://benchmark.fyi/f" target="_blank" rel="noopener noreferrer">the results for this test on benchmark.fyi</a>. The <a href="https://github.com/rossta/loves-enumerable/blob/edbab0fcb2aeac65a7b34d9fa603b3aa58563b4f/code/snake_case.rb" target="_blank" rel="noopener noreferrer">full source code is also on GitHub</a>.</p>

      <h3 id="and-the-winner-is-" class="title title-h3">
        <a name="and-the-winner-is-" class="anchor" href="#and-the-winner-is-">       <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16">
       <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
       </svg>
</a>
        And the winner is...
      </h3>
    
<p>All of the above!</p>

<p>This serves as a good illustration of how there&#39;s often no single &quot;best&quot; way to
solve a problem with considering the circumstance. In a situation where
performance matters, the mathematical approach has a clear advantage, but
sacrifices readability. I might be inclined to choose the iterative or recursive
approach in situations where performance isn&#39;t the key concern.</p>

<p>Given my preference for <a href="https://rossta.net/blog/series/enumerable.html" target="_blank" rel="noopener noreferrer">Enumerable</a>, I personally love the enumerative approach, but, as <a href="https://rossta.net/talks/ruby-enumerator.html" target="_blank" rel="noopener noreferrer">I discussed at Ancient City Ruby</a>, I doubt most would agree.</p>

  </article>
  <section class="mb-12">
    <p class="text-right">
      <a href="https://twitter.com/intent/tweet?text=Ancient%20City%20Ruby%20Snake%20Case%20-%20rossta.net&amp;url=https%3A%2F%2Frossta.net%2Fblog%2Fancient-city-snake-case.html" class="font-bold" target="_blank" rel="noopener noreferrer">Discuss it on Twitter</a>
      &middot;
      <span class="italic font-light">
          Part of the <a href="/blog/series/enumerable.html">Enumerable</a> series.
        Published on Apr 12, 2016
      </span>
    </p>
  </section>
  <section class="signup-form-standalone hero">
    <script src="https://f.convertkit.com/ckjs/ck.5.js" async></script>
<form
  action="https://app.convertkit.com/forms/818387/subscriptions?ref=Ruby"
  class="seva-form formkit-form"
  method="post"
  data-sv-form="818387"
  data-uid="cda82aafbf"
  data-format="inline"
  data-version="5"
  data-options="{&quot;settings&quot;:{&quot;after_subscribe&quot;:{&quot;action&quot;:&quot;message&quot;,&quot;success_message&quot;:&quot;Success! Now check your email to confirm your subscription.&quot;,&quot;redirect_url&quot;:&quot;&quot;},&quot;modal&quot;:{&quot;trigger&quot;:&quot;timer&quot;,&quot;scroll_percentage&quot;:null,&quot;timer&quot;:&quot;300&quot;,&quot;devices&quot;:null,&quot;show_once_every&quot;:&quot;7&quot;},&quot;recaptcha&quot;:{&quot;enabled&quot;:false},&quot;return_visitor&quot;:{&quot;action&quot;:&quot;show&quot;,&quot;custom_content&quot;:&quot;&quot;},&quot;slide_in&quot;:{&quot;display_in&quot;:null,&quot;trigger&quot;:null,&quot;scroll_percentage&quot;:null,&quot;timer&quot;:null,&quot;devices&quot;:null,&quot;show_once_every&quot;:null}}}"
>
  <div>
    <div class="mb-4">
      <h3 class="mb-2">
  Join the Newsletter
</h3>
<p>
  Subscribe to get an occasional email about web development and Rails. Thank you!
</p>

    </div>
    <ul class="formkit-alert formkit-alert-error" data-element="errors" data-group="alert"></ul>
    <div data-element="fields" data-stacked="false" class="seva-fields formkit-fields">
      <div class="formkit-field">
        <label for="email_address" class="sr-only">Email address</label>
        <input
          class="formkit-input"
          id="email_address"
          name="email_address"
          placeholder="Your email address"
          required=""
          type="email"
          style="border-color: rgb(227, 227, 227); border-radius: 4px; color: rgb(0, 0, 0); font-weight: 400;"
        />
      </div>
      <button
        data-element="submit"
        class="formkit-submit button button-green"
      >
        <div class="formkit-spinner">
          <div></div>
          <div></div>
          <div></div>
        </div>
        <span>Subscribe</span>
      </button>
    </div>
  </div>
  <style>
  </style>
    <input type="hidden" name="tags[]" value="733960" />
  <input type="hidden" aria-label="URL" name="fields[url]" placeholder="URL" value="https://rossta.net/blog/ancient-city-snake-case.html" />
</form>


  </section>
  <section class="index-posts mb-24">
    <h2 class="mb-8">More posts</h2>
      <article class="index-post">
    <header class="index-title">
      <a href="/blog/how-to-specify-local-ruby-gems-in-your-gemfile.html">How to specify local Ruby gems in your Gemfile</a>
    </header>
      <p>Use the "bundle config" command to develop against local Ruby gems instead of following the typical advice to specify the :path option in your Gemfile.</p>
  </article>
  <article class="index-post">
    <header class="index-title">
      <a href="/blog/using-webpack-with-middleman.html">Using webpack with Middleman</a>
    </header>
      <p>Explaining how to integrate the webpack asset management tool with the Ruby static web framework Middleman</p>
  </article>
  <article class="index-post">
    <header class="index-title">
      <a href="/blog/a-ruby-antihero-thread-pool.html">Thread Pool - A Ruby Antihero</a>
    </header>
      <p>A thread pool is an abstraction for re-using a limited number of threads for performing work concurrently to save resources</p>
  </article>

  </section>
  <article class="mb-24">
      <figure>
        <img src="/assets/images/blog/stock/snakes-pexels-photo.jpg" loading="lazy" alt="" />
      </figure>
  </article>

    </main>
    <footer class="bg-silver text-xs">
  <div class="layout container p-6">
    <img src="/assets/images/turtle-logo.svg" loading="lazy" class="turtle w-8 mb-6" alt="" />
    <section class="lg:flex lg:justify-between">
      <section class="mb-8">
        <h5 class="font-bold mb-4">Most Popular</h5>
        <ul>
            <li class="mb-1"><a href="/blog/why-does-rails-install-both-webpacker-and-sprockets.html">Why does Rails 6 include both Webpacker and Sprockets?</a></li>
            <li class="mb-1"><a href="/blog/reasons-to-switch-to-webpacker.html">25 reasons to switch to Webpack(er)</a></li>
            <li class="mb-1"><a href="/blog/webpacker-with-bootstrap.html">Using Bootstrap with Rails Webpacker</a></li>
            <li class="mb-1"><a href="/blog/importing-images-with-webpacker.html">Importing images with Webpacker</a></li>
            <li class="mb-1"><a href="/blog/from-sprockets-to-webpack.html">How we switched from Sprockets to Webpacker</a></li>
        </ul>
      </section>
      <section class="mb-8">
        <h5 class="font-bold mb-4">
          <a class="text-gray-900 hover:text-gray-700" href="blog/tags.html">
            Categories
          </a>
        </h5>
        <ul>
            <li class="mb-1"><a href="/blog/tags/rails.html">Rails</a></li>
            <li class="mb-1"><a href="/blog/tags/ruby.html">Ruby</a></li>
            <li class="mb-1"><a href="/blog/tags/webpack.html">Webpack</a></li>
            <li class="mb-1"><a href="/blog/tags/javascript.html">JavaScript</a></li>
            <li class="mb-1"><a href="/blog/tags/vue.html">Vue</a></li>
        </ul>
      </section>
      <section class="mb-8">
        <h5 class="font-bold mb-4">Contact</h5>
        <ul>
          <li class="mb-1"><a target="_blank" href="mailto:ross@rossta.net" rel="me noopener nofollow">email</a></li>
          <li class="mb-1"><a target="_blank" href="https://twitter.com/rossta" rel="me noopener nofollow">twitter</a></li>
          <li class="mb-1"><a target="_blank" href="https://github.com/rossta" rel="me noopener nofollow">github</a></li>
          <li class="mb-1"><a target="_blank" href="https://www.linkedin.com/in/rosskaffenberger" rel="me noopener nofollow">linkedin</a></li>
          <li class="mb-1"><a target="_blank" href="https://stackoverflow.com/users/771838/rossta?tab=profile" rel="me noopener nofollow">stackoverflow</a></li>
        </ul>
      </section>
    </section>
    <p class="copyright text-center text-xs font-light">
      © 2023 Ross Kaffenberger. All rights reserved.
    </p>
  </div>
</footer>

    <script src="/js/runtime.ab3e4b5316b2997723cc.js"></script>"<script src="/js/app.d1ef27c9a26cf7bc4240.js"></script>"
    
  </body>
</html>
