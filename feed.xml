<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rossta.net</title>
  <subtitle>Ross Kaffenberger</subtitle>
  <id>https://rossta.net/</id>
  <link href="https://rossta.net/"/>
  <link href="https://rossta.net/feed.xml" rel="self"/>
  <updated>2016-02-21T19:00:00-05:00</updated>
  <author>
    <name>Ross Kaffenberger</name>
  </author>
  <entry>
    <title>What I learned building an app in Hanami</title>
    <link rel="alternate" href="/blog/what-i-learned-about-hanami.html"/>
    <id>/blog/what-i-learned-about-hanami.html</id>
    <published>2016-02-21T19:00:00-05:00</published>
    <updated>2016-02-21T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;For the past year, I’ve been loosely following the progress on &lt;a href="http://hanamirb.org"&gt;Hanami&lt;/a&gt; (formerly Lotus), a new web framework
for Ruby created by &lt;a href="https://github.com/jodosha"&gt;Luca Guidi (@jodosha)&lt;/a&gt;. I recently decided to build a small app in Hanami to get a feel for its design and to understand...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;For the past year, I&amp;rsquo;ve been loosely following the progress on &lt;a href="http://hanamirb.org"&gt;Hanami&lt;/a&gt; (formerly Lotus), a new web framework
for Ruby created by &lt;a href="https://github.com/jodosha"&gt;Luca Guidi (@jodosha)&lt;/a&gt;. I recently decided to build a small app in Hanami to get a feel for its design and to understand better its fresh perspective on web development in Ruby. In other words, to answer for myself, &amp;ldquo;Is Hanami better than Rails?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/rossta/github_groove"&gt;The app&lt;/a&gt; is a simple integration between GitHub issues and the helpdesk platform, &lt;a href="https://www.groovehq.com"&gt;Groove&lt;/a&gt;.
Visitors can login via OAuth through their GitHub accounts, connect to a Groove
account with an API key, import their Groove tickets, and create GitHub issues
from these tickets through the app. You can see the &lt;a href="https://github.com/rossta/github_groove"&gt;source on Github&lt;/a&gt; and play with the &lt;a href="https://github-groove.herokuapp.com/"&gt;app hosted on Heroku&lt;/a&gt;, where it would help to have accounts on both GitHub and Groove to see how it works.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve made note of what I learned and some of the challenges I faced while going beyond the &lt;a href="http://hanamirb.org/guides/"&gt;getting
started guides&lt;/a&gt; to build and deploy the app. This post is not an introduction
to Hanami - the &lt;a href="http://hanamirb.org/guides/"&gt;guides&lt;/a&gt; serve as an excellent overview.&lt;/p&gt;

&lt;aside class="callout panel"&gt;
  &lt;p&gt;The Github-Groove app is built on &lt;code&gt;hanami-0.7.0&lt;/code&gt;. As the framework is under
heavy development (as of this writing the latest version is
&lt;code&gt;v0.7.2&lt;/code&gt;), your experience getting started with Hanami may differ.
  &lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Hanami opinions are not Rails opinions&lt;/h3&gt;

&lt;p&gt;Hanami has a lot in common with Rails. Both are web frameworks built on Ruby
that employ some version of the Model-View-Controller pattern and, among other
things, value &lt;a href="http://rubyonrails.org/doctrine/#convention-over-configuration"&gt;convention over configuration&lt;/a&gt;.
Both frameworks are &lt;em&gt;opinionated&lt;/em&gt; about how web apps should be built. In a
nutshell, Hanami takes what it likes from Rails and draws the line on certain
principles including avoidance of monkey-patching, enforcing modularity, and encouraging
the use of &amp;ldquo;plain old Ruby objects&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re coming from Rails, you can expect to learn some new conventions in Hanami.
&lt;a href="http://hanamirb.org/guides/getting-started/"&gt;As the guides warn&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;learning these conventions may be hard: without change, there is no challenge&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The framework pushes you toward &amp;ldquo;monolith first&amp;rdquo; while emphasizing &amp;ldquo;separation of concerns&amp;rdquo;. There are suggestions in the generated directory structure like how the &lt;code&gt;app/&lt;/code&gt; folder is named &lt;code&gt;apps/&lt;/code&gt; in Hanami encouraging you from the start to define sub-applications boundaries under one umbrella, or &amp;ldquo;container&amp;rdquo; in Hanami parlance. So while in Rails has engines as an opt-in feature, you build everything as an engine in Hanami. Each &amp;ldquo;app&amp;rdquo; gets its own set of views, controllers, assets, configuration, etc. Shared resources, like models, tend to go in &lt;code&gt;lib/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You also get useful development tools like generators, migrations, and asset
pipelines in Hanami, but expect less ceremony here. Migrations handed off to the
venerable &lt;a href="http://sequel.jeremyevans.net/rdoc/files/doc/schema_modification_rdoc.html"&gt;Sequel&lt;/a&gt; project and the asset story is still young but passable; you won&amp;rsquo;t be able to take advantage of the multitude of Rails-asset gems.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d be interested to see Hanami go in a different direction here, like taking advantage of the &amp;ldquo;frontend explosion&amp;rdquo; by providing integration with external pipelines like the static-site generator &lt;a href="https://middlemanapp.com/advanced/external-pipeline/"&gt;middleman&lt;/a&gt; or what Shakacode has done with &lt;a href="https://webpack.github.io/"&gt;webpack&lt;/a&gt; in &lt;a href="https://github.com/shakacode/react_on_rails"&gt;&lt;code&gt;react_on_rails&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One gotcha is that Hanami &lt;a href="https://github.com/hanami/hanami/issues/249"&gt;does not itself provide any mechanism for code
reloading&lt;/a&gt; (at the moment). This
was not obvious to me starting off since the development server does &amp;ldquo;appear&amp;rdquo; to reload code. It turns out that the dev server launches with &lt;a href="https://github.com/rtomayko/shotgun"&gt;Shotgun&lt;/a&gt; (commonly used in Sinatra projects), to serve each development request in a new process with &lt;code&gt;fork(2)&lt;/code&gt;. I didn&amp;rsquo;t pick up on this until several iterations in when I added the &lt;a href="https://github.com/brandonhilkert/sucker_punch"&gt;SuckerPunch gem&lt;/a&gt; and couldn&amp;rsquo;t figure out why my background jobs wouldn&amp;rsquo;t run in development. Long story short, kicking off background jobs in threads in the request process, as is possible with SuckerPunch, won&amp;rsquo;t work without disabling Shotgun.&lt;/p&gt;

&lt;h3&gt;Hanami MVC is not Rails MVC&lt;/h3&gt;

&lt;p&gt;With the Model-View-Controller paradigm, you&amp;rsquo;ll see some big departures from
Rails. First, controllers are not classes with &amp;ldquo;RESTful&amp;rdquo; methods, but
&lt;em&gt;directories&lt;/em&gt; of related action classes. In other words, instead of defining
&lt;code&gt;#index&lt;/code&gt;, &lt;code&gt;#show&lt;/code&gt;, &lt;code&gt;#create&lt;/code&gt;, etc. in a &lt;code&gt;PostsController&lt;/code&gt;, you create a separate
class for each action using a mixin that live in a directory that would
represent a single controller in Rails.&lt;/p&gt;

&lt;p&gt;In my Github-Groove app, here&amp;rsquo;s how I organize the tickets controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;app/
  web/
    assets/
    config/
    controllers/
      tickets/
        index.rb
        show.rb
        sync.rb
    templates/
    views/
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each &amp;ldquo;action&amp;rdquo; is a Rack-inspired class whose contract is only that it responds to &lt;code&gt;#call&lt;/code&gt;. You still get
familiar macros like &lt;code&gt;before&lt;/code&gt; filters, but there are new idea too, like declaring what instance variables are available to the view with &lt;code&gt;expose&lt;/code&gt;, inserting action-specific middleware, and whitelisting &lt;code&gt;params&lt;/code&gt; at the class level, all of which I find to be huge improvements over the Rails controller design.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Web::Controllers::Project
  class Create
    include Web::Action

    expose :project
    before :authenticate!

    params do
      param :project do
        param :groove_access_token, presence: true
        param :github_repository, presence: true
      end
    end

    def call(params)
      if params.valid?
        @project = ProjectRepository.find_or_create_by_params(params[:project])
        UserRepository.update_user_project(current_user, @project)

        flash[:notice] = &amp;quot;Your project has been saved!&amp;quot;

        redirect_to &amp;quot;/project&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arguably, the biggest efforts in Hanami appear to be at this action layer and it
shows in the &lt;a href="http://hanamirb.org/guides/actions/overview/"&gt;guides&lt;/a&gt; and the
&lt;a href="https://github.com/hanami/controller/blob/master/README.md"&gt;README&lt;/a&gt; where you
can find a ton of great information customizing these classes.&lt;/p&gt;

&lt;p&gt;Another big benefit in the controller design, and for most of the Hanami
framework, is that unit-testing has a much lower barrier to entry. To get
controller tests to work in Rails requires a ton of setup behind the scenes to
the point where you essentially have integration tests. Controllers tests in
Hanami are much simpler by the simple fact that getting a testable object is as
easy as &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/spec/web/controllers/project/create_spec.rb#L5"&gt;instantiating a Hanami action&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Hanami, &amp;ldquo;views&amp;rdquo; are classes that act more like presenter to represent a model
or collection of models for the &amp;ldquo;templates&amp;rdquo;, which the place of the
&lt;code&gt;views/&lt;/code&gt; folder in Rails. Like Rails, file-naming conventions link an action,
view, and template. The helper method story is still developing, but you can
expect to find some surprises in the docs, like the criticism of Rails
monkey-patching of ERB to achieve block-style helpers for things like forms.
Expect to get tripped up by these differences in helper syntax which ironically are
valid ERB. Hanami does support all the other popular templating engines through
&lt;a href="https://github.com/rtomayko/tilt"&gt;Tilt&lt;/a&gt; for your preference.&lt;/p&gt;

&lt;p&gt;Hanami also provides &lt;code&gt;hanami-model&lt;/code&gt; for the model layer as a soft-dependency so
you can bring your own ORM if desired. If you choose to use &lt;code&gt;hanami-model&lt;/code&gt; as I
did, you can expect to leave your ActiveRecord convenience (and baggage) behind.
Hanami&amp;rsquo;s model layer emulates the &lt;a href="http://martinfowler.com/eaaCatalog/repository.html"&gt;repository pattern&lt;/a&gt; where database queries, table mapping, and entities are all separate concerns.&lt;/p&gt;

&lt;p&gt;Repositories become a collection of query methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProjectRepository
  include Hanami::Repository

  def self.find_or_create_by_params(params)
    found = find_by_groove_access_token(params[:groove_access_token])

    if found
      found.update(params)
      update found
    else
      create(Project.new(params))
    end
  end

  def self.find_by_groove_access_token(groove_access_token)
    query do
      where(groove_access_token: groove_access_token)
    end.first
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entities feel basically like POROS that provide a thin layer over attributes.
Don&amp;rsquo;t expect to find any database access, validations (by default anyhow), or callbacks here.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Project
  include Hanami::Entity

  attributes :groove_access_token, :github_repository, :syncing

  def ready?
    groove_access_token.present? &amp;amp;&amp;amp; github_repository.present?
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Validations do exist in Hanami &lt;a href="https://github.com/hanami/validations"&gt;as a separate mixin&lt;/a&gt; but these are more typically done in the params macro at the action-layer.&lt;/p&gt;

&lt;h2&gt;Expect to write code&lt;/h2&gt;

&lt;p&gt;While Hanami has its own variety of &amp;ldquo;magic&amp;rdquo; of the kind that developers have come to
either love or hate in Rails, you can expect to write code you might not
otherwise have to in Rails. The framework is still young, so there are missing
features. What&amp;rsquo;s not always clear is whether these features have been left out
by priority or choice. To figure that out takes some digging on GitHub issues, the Hanami &lt;a href="https://gitter.im/hanami/chat"&gt;chat&lt;/a&gt; and &lt;a href="https://discuss.hanamirb.org/"&gt;Discourse forum&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Though its database layer has the &lt;a href="https://github.com/jeremyevans/sequel"&gt;Sequel&lt;/a&gt; library as a foundation, I didn&amp;rsquo;t find the repository and entity functionality as fully-developed. I found myself writing a lot of boilerplate code in the entities and repositories with a lot of co-dependence between the classes. With some more thoughtful design and refactoring, I could probably address this issue, but at this stage, the separation of concerns is less apparent: entities and repositories appear to be tightly bound. &lt;a href="https://github.com/hanami/model/issues/291"&gt;Convenience methods&lt;/a&gt; are still in the works.&lt;/p&gt;

&lt;p&gt;For one, &lt;a href="https://github.com/hanami/model/pull/244"&gt;associations&lt;/a&gt; are still in development at the time of this writing (see open issue &lt;a href="https://github.com/hanami/model/issues/35"&gt;here&lt;/a&gt;). Much of my entity code was to fill this gap - to load objects linked by foreign keys via repositories like below.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Project
  include Hanami::Entity

  def tickets(params = {})
    TicketRepository.all_by_project(self, params)
  end
end

class TicketRepository
  include Hanami::Repository

  def self.all_by_project(project, _params = {})
    query do
      where(project_id: project.id).desc(:number)
    end.all
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m not sure if this is the &amp;ldquo;Hanami-way&amp;rdquo;, but I found myself doing this kind of
thing a lot.&lt;/p&gt;

&lt;p&gt;I also ran into some unexpected issues while deploying the application to Heroku
where its &lt;code&gt;HANAMI_ENV&lt;/code&gt; is set to &lt;code&gt;&amp;#39;production&amp;#39;&lt;/code&gt;. In many cases, custom classes I
extracted, like one for sharing &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/lib/github_groove/repositories/pagination.rb"&gt;a pagination query&lt;/a&gt; and another for &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/lib/github_groove/vendor/groove.rb"&gt;wrapping the &lt;code&gt;Groove API Ruby Client&lt;/code&gt;&lt;/a&gt; weren&amp;rsquo;t &amp;ldquo;autoloaded&amp;rdquo; when booting the Hanami application. To resolve this, I added explicit requires like &lt;code&gt;require_relative &amp;#39;./pagination&amp;#39;&lt;/code&gt;. Again, I didn&amp;rsquo;t have time to dig into whether this issue would be expected or not; I could have been missing something important here.&lt;/p&gt;

&lt;h3&gt;The Community is still young&lt;/h3&gt;

&lt;p&gt;That brings me to the community - it&amp;rsquo;s extremely supportive, but still very
small. I encountered a lot of helpful folks on
&lt;a href="https://gitter.im/hanami/chat"&gt;chat&lt;/a&gt; including &lt;code&gt;@jodosha&lt;/code&gt; himself, but there
simply hasn&amp;rsquo;t been enough traction to reach &lt;a href="https://stackoverflow.com/questions/tagged/hanami"&gt;StackOverflow&lt;/a&gt; critical mass where just about any question you can think of in Rails already has an answer.&lt;/p&gt;

&lt;p&gt;This means a lot more code-spelunking in the &lt;a href="https://github.com/hanami"&gt;hanami&lt;/a&gt; repositories. To that end, I found the code extremely clean, well-documented, and approachable whereas, even today, I need to brace myself before diving into Rails source.&lt;/p&gt;

&lt;p&gt;That said, you can expect to run into edge cases and bugs occasionally that may
not yet have a solution, including this &lt;a href="https://github.com/pry/pry/issues/1471#issuecomment-187420164"&gt;incredibly irksome&lt;/a&gt; issue that prevents you from accessing the pry console when using &lt;code&gt;binding.pry&lt;/code&gt; in Hanami controllers and the problem I mentioned earlier that prevents you from using SuckerPunch in development with Shotgun enabled.&lt;/p&gt;

&lt;p&gt;Another challenge is that all those Rails-specific plugins
you love have no place here. Yes, you can build authentication without Devise.
Using &lt;a href="https://github.com/hassox/warden"&gt;&lt;code&gt;Warden&lt;/code&gt;&lt;/a&gt;, the general Rack-based
authentication middleware on which Devise is based, is very feasible and you can always
rely on &lt;a href="https://github.com/rossta/github_groove/blob/4cb64e1a92013cf6eb56a3abd6678020640eaf5c/apps/web/application.rb#L86"&gt;OmniAuth like I did&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The lesson here is that with Hanami, you&amp;rsquo;re much more likely to have to &amp;ldquo;roll up
your sleeves&amp;rdquo; to get to the bottom of issues or&lt;/p&gt;

&lt;h3&gt;Hanami is and is not Rails&lt;/h3&gt;

&lt;p&gt;So should you build your next app in Hanami? Only you can answer that of course.
The lightweight approach in Hanami means there is less to wrap your head around
if you&amp;rsquo;re coming from Rails, but there is still a learning curve nonetheless. I&amp;rsquo;d say it&amp;rsquo;s a worthwhile endeavor to build something small like I did at first to push the boundaries and answer the questions you have about Hanami for yourself.&lt;/p&gt;

&lt;p&gt;Hanami treads the same ground as Rails and aims to do a lot of the low level
work for you so can focus on what&amp;rsquo;s important - the business. Personally, I found a lot of advantages in the &amp;ldquo;Hanami-way&amp;rdquo; and enjoyed the experience of the new paradigms. My &amp;ldquo;Rails muscle memory&amp;rdquo; tripped me up on occasion and left me pining for features that don&amp;rsquo;t exist or are not as well-developed in Hanami yet. I see a lot of potential in the Hanami framework and see it growing into a viable alternative to Rails in the near future.&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href="https://github.com/rossta/github_groove"&gt;GitHub-Groove source&lt;/a&gt; and &lt;a href="https://github-groove.herokuapp.com/"&gt;demo app&lt;/a&gt; and let me know what I could have done differently.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Clojure's iterate in Ruby</title>
    <link rel="alternate" href="/blog/clojure-iterate-in-ruby.html"/>
    <id>/blog/clojure-iterate-in-ruby.html</id>
    <published>2016-02-16T19:00:00-05:00</published>
    <updated>2016-02-16T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;In functional languages, the key building blocks are functions and data. Clojure has a particularly interesting data structure, &lt;a href="http://clojure.org/sequences"&gt;sequences&lt;/a&gt;, not featured in the Ruby standard library. A Clojure sequence is an immutable collection that representing the result of an algorithm. Previously, I described how to generate Clojure-like &lt;a href="https://rossta.net/blog/pascals-triangle-with-rubys-enumerator.html"&gt;sequences in Ruby&lt;/a&gt; (without the immutability anyways), including &lt;a href="https://rossta.net/blog/infinite-sequences-in-ruby.html"&gt;Pascal&amp;rsquo;s Triangle&lt;/a&gt; using &lt;code&gt;Enumerator&lt;/code&gt;, which allows us to package up an algorithm as an object that can emit values as any &amp;ldquo;eager&amp;rdquo; collection can, like &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Clojure provides a few functions that can be used to generate sequences,
including &lt;code&gt;iterate&lt;/code&gt;. According to the &lt;a href="https://clojuredocs.org/clojure.core/iterate"&gt;docs&lt;/a&gt;,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In other words, &lt;code&gt;iterate&lt;/code&gt; will emit values starting with the first and repeatedly call the given function with the return value of the previous call.&lt;/p&gt;

&lt;p&gt;The signature in Clojure looks this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;(iterate f x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we can generate a simple sequence of numbers using the &lt;code&gt;inc&lt;/code&gt; function and some start value:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate inc 1)
(1 2 3 4 5 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we have a terse was of generating a sequence like this in Ruby:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb(main)&amp;gt; (1..5).to_a
=&amp;gt; [1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this solution doesn&amp;rsquo;t generalize to other types of sequences like, for instance,
generating a sequence of the powers of 2. In the example below, &lt;code&gt;(partial * 2)&lt;/code&gt;
returns a function that multiplies a single argument by 2.&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (iterate (partial * 2) 1)
(1 2 4 8 16 32 64 128 ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get this result in Ruby, we might try something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; (1..7).each_with_object([]) { |n, seq| seq &amp;lt;&amp;lt; (seq.last.nil? ? n : seq.last * 2) }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not very pretty (ok, I admit that&amp;rsquo;s a strawman). But this also is an &amp;ldquo;eagerly&amp;rdquo;
generated collection whereas we want something that can be lazily generated to
get closer to Clojure.&lt;/p&gt;

&lt;p&gt;While there may be a number of ways to generate these sequences in Ruby, for this
exercise, we also want something that has a similar signature to Clojure&amp;rsquo;s &lt;code&gt;iterate&lt;/code&gt;,
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(x, &amp;amp;block)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll leverage Ruby&amp;rsquo;s method block convention in place of the function, &lt;code&gt;f&lt;/code&gt;.
Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;irb&amp;gt; iterate(1) { |n| n + 1 }
=&amp;gt; [1, 2, 3, 4, 5, ...]
irb&amp;gt; iterate(1) { |n| n * 2 }
=&amp;gt; [1, 2, 4, 8, 16, 32, 64, ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two examples now have the same &amp;ldquo;surface area&amp;rdquo; and have a lot in common with the Clojure
companions. So how would we implement this?&lt;/p&gt;

&lt;p&gt;First a test. By the way, all the code found in the following examples is &lt;a href="https://github.com/rossta/loves-enumerable/tree/master/examples/sequence"&gt;on Github&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;minitest/autorun&amp;#39;
require_relative &amp;#39;./sequence&amp;#39;

class TestSequence &amp;lt; Minitest::Test
  include Sequence

  def test_iterate_increment
    sequence = iterate(1) { |x| x + 1 }

    assert_equal sequence.first(5), [1, 2, 3, 4, 5]
  end

  def test_iterate_power_of_2
    sequence = iterate(1) { |x| x * 2 }

    assert_equal sequence.first(5), [1, 2, 4, 8, 16]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re going to implement &lt;code&gt;iterate&lt;/code&gt; in a Ruby module called &lt;code&gt;Sequence&lt;/code&gt;. Our test
for &lt;code&gt;iterate&lt;/code&gt; will return an instance of &lt;code&gt;Enumerator&lt;/code&gt; (the &lt;code&gt;sequence&lt;/code&gt; variable).
The enumerator allows use to generate the sequence on demand with the call to
&lt;code&gt;#first&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg)
    Enumerator.new do |yielder|
      current = arg
      loop do
        yielder &amp;lt;&amp;lt; current
        current = yield(current)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our implementation of &lt;code&gt;iterate&lt;/code&gt; returns an &lt;code&gt;Enumerator&lt;/code&gt; that will first yield
the given &lt;code&gt;arg&lt;/code&gt; and repeatedly call the given block with the result of the
previous call. The &lt;code&gt;loop&lt;/code&gt; construct means this enumeration can potentially
continue forever - capturing the spirit of a Clojure sequence. That means
we need to use a terminating functions like &lt;code&gt;#first&lt;/code&gt; or &lt;code&gt;#take&lt;/code&gt; to limit the
results, just like we would in Clojure:&lt;/p&gt;

&lt;pre&gt;&lt;code class="clojure"&gt;=&amp;gt; (take 5 (iterate (partial * 2) 1))
(1 2 4 8 16)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Ruby equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;iterate(1) { |n| n * 2 }.take(5)
=&amp;gt; [1, 2, 4, 8, 16]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could go one step further an make this method work as a mixin. Below is a
test for using &lt;code&gt;iterate&lt;/code&gt; as an instance method of a class using in our tests
that will simply delegate missing methods to the object passed in on
instantiation.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class TestSequence &amp;lt; Minitest::Test
  include Sequence

  class Sequenced &amp;lt; SimpleDelegator
    include Sequence
  end

  def test_iterate_include
    num = Sequenced.new(0)

    sequence = num.iterate { |x| x - 1 }
    assert_equal sequence.first(5), [0, -1, -2, -3, -4]
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make this pass, we need only set the default arg to &lt;code&gt;self&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;module Sequence
  def iterate(arg = self)
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what? Ok, well, you may be hard pressed to use &lt;code&gt;iterate&lt;/code&gt; in your daily work,
but there is certainly more room to think about data processing as functional
operations (free of side effects) on sequences (values that can be generated on demand). Something like &lt;code&gt;iterate&lt;/code&gt; need not apply to only numbers; you can imagine sequences of letters, time objects, or POROs also being generated. At times, Rubyist are too quick to wrap collections in other classes when simpler, more generalizable &amp;ldquo;functional&amp;rdquo; transforms could suffice.&lt;/p&gt;

&lt;p&gt;When I started &lt;a href="http://devpost.com/software/learning-clojure"&gt;learning Clojure&lt;/a&gt; last year, I got really excited about the functional aspects of Ruby. &amp;ldquo;Wait, I thought everything in Ruby is an object.&amp;rdquo; Yes, but a great thing about Ruby is its &lt;a href="http://yehudakatz.com/2009/07/11/python-decorators-in-ruby/"&gt;ability to adopt aspects of other languages&lt;/a&gt;. As Piotr Solnica illustrates in &lt;a href="https://speakerdeck.com/solnic/blending-functional-and-oo-programming-in-ruby"&gt;his recent talk&lt;/a&gt;, blending functional techniques with our OO code can have a lot of benefits including avoidance of side effects and favoring composability. Introducing sequence-generating methods, like we saw here, is just one small idea to help sprinkle a little functional flavor into your Ruby code.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Recurring events in Ruby</title>
    <link rel="alternate" href="/blog/recurring-events-in-ruby.html"/>
    <id>/blog/recurring-events-in-ruby.html</id>
    <published>2016-02-02T19:00:00-05:00</published>
    <updated>2016-02-02T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo.jpg?1455138702"&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I’d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="How many more times?" src="/assets/images/blog/stock/clock-pexels-photo.jpg?1455138702" /&gt;&lt;/p&gt;

&lt;p&gt;I was considering recently how I&amp;rsquo;d build an &lt;a href="http://meetedgar.com/"&gt;Edgar&lt;/a&gt; clone to post updates about &lt;a href="/"&gt;rossta.net&lt;/a&gt; on Twitter and LinkedIn at recurring intervals, for example, every Tuesday at 9AM EST.&lt;/p&gt;

&lt;p&gt;For scheduling tasks, we have &lt;a href="http://www.unixgeeks.org/security/newbie/unix/cron-1.html"&gt;cron&lt;/a&gt; at the system level and even such options as the &lt;a href="https://github.com/javan/whenever"&gt;&lt;code&gt;whenever&lt;/code&gt;&lt;/a&gt; gem to setup cron from Rails and Sinatra applications. Rubyists can also take advantage of fantastic background job schedulers like &lt;a href="https://github.com/jmettraux/rufus-scheduler"&gt;&lt;code&gt;rufus-scheduler&lt;/code&gt;&lt;/a&gt; to run recurring tasks from a separate process or even an API for defining repeating &lt;a href="https://github.com/mperham/sidekiq"&gt;&lt;code&gt;Sidekiq&lt;/code&gt;&lt;/a&gt; jobs with &lt;a href="https://github.com/tobiassvn/sidetiq"&gt;&lt;code&gt;Sidetiq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For an Edgar clone though, we need a layer for users of the application to define their own recurrences. This means finding a way to represent time-based recurrences which are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;serializable, so we can save them to the database, and&lt;/li&gt;
&lt;li&gt;enumerable, so we can determine when the next post(s) should be shared on designated social networks.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s an interesting problem to model. While we have classes like &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;Date&lt;/code&gt;, and event &lt;code&gt;ActiveSupport::Duration&lt;/code&gt;, it&amp;rsquo;s more elusive to consider recurrences. I mean, what does it mean to represent the meeting time of my &lt;a href="http://www.meetup.com/NYC-rb/"&gt;NYC.rb&lt;/a&gt; meetup: &amp;ldquo;every second Tuesday of the month at 7pm&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Solutions for this exist in Ruby, namely &lt;a href="https://github.com/seejohnrun/ice_cube"&gt;&lt;code&gt;ice_cube&lt;/code&gt;&lt;/a&gt;. If you&amp;rsquo;re looking for a mature, up-to-date project devoted to modeling recurring events in Ruby, please check it out. I did, and highly recommend it. After playing with it for awhile, I found felt the urge for alternative semantics - like the ability to define a recurrence without a start date - and API similar to the hash-like syntax provided by another less-active recurring events library, &lt;a href="https://github.com/fnando/recurrence"&gt;&lt;code&gt;recurrence&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I thought of the &lt;a href="https://github.com/httprb/http"&gt;&lt;code&gt;HTTP&lt;/code&gt;&lt;/a&gt; gem which bills
itself as the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP (The Gem! a.k.a. http.rb) is an easy-to-use client library for making requests from Ruby. It uses a simple method chaining system for building requests, similar to Python&amp;rsquo;s &lt;a href="http://docs.python-requests.org/en/latest/"&gt;Requests&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Taking a cue from &lt;code&gt;http.rb&lt;/code&gt; and the &lt;code&gt;recurrence&lt;/code&gt; gem, I set out to create something similar for recurring events.&lt;/p&gt;

&lt;p&gt;Introducing &lt;a href="https://github.com/rossta/montrose"&gt;&lt;code&gt;Montrose&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Montrose allows you to easily create &amp;ldquo;recurrence&amp;rdquo; objects through chaining:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every Monday at 10:30am
Montrose.weekly.on(:monday).at(&amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or the constructor hash-syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Montrose::Recurrence.new(every: :week, on: :monday, at: &amp;quot;10:30 am&amp;quot;)
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Montrose recurrence responds to &lt;code&gt;#events&lt;/code&gt;, which returns an &lt;a href="/blog/what-is-enumerator.html"&gt;&lt;code&gt;Enumerator&lt;/code&gt;&lt;/a&gt; that can generate timestamps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.hourly
=&amp;gt; #&amp;lt;Montrose::Recurrence...&amp;gt;

r.events
=&amp;gt; #&amp;lt;Enumerator:...&amp;gt;

r.events.take(10)
=&amp;gt; [2016-02-03 18:26:08 -0500,
2016-02-03 19:26:08 -0500,
2016-02-03 20:26:08 -0500,
2016-02-03 21:26:08 -0500,
2016-02-03 22:26:08 -0500,
2016-02-03 23:26:08 -0500,
2016-02-04 00:26:08 -0500,
2016-02-04 01:26:08 -0500,
2016-02-04 02:26:08 -0500,
2016-02-04 03:26:08 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Montrose recurrences are themselves enumerable:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every month starting a year from now on Friday the 13th for 5 occurrences
r = Montrose.monthly.starting(1.year.from_now).on(friday: 13).repeat(5)

r.map(&amp;amp;:to_date)
=&amp;gt; [Fri, 13 Oct 2017,
Fri, 13 Apr 2018,
Fri, 13 Jul 2018,
Fri, 13 Sep 2019,
Fri, 13 Dec 2019]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each chained recurrence returns a new object so they can be composed and
merged:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every week
r1 = Montrose.every(:week)
r2 = Montrose.on([:tuesday, :thursday])
r3 = Montrose.at(&amp;quot;12 pm&amp;quot;)
r4 = Montrose.total(4)

r1.merge(r2).merge(r3).merge(r4).to_a
=&amp;gt; [2016-02-04 12:00:00 -0500,
2016-02-09 12:00:00 -0500,
2016-02-11 12:00:00 -0500,
2016-02-16 12:00:00 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With a nod to DHH and the &lt;a href="http://rubyonrails.org/doctrine"&gt;Rails doctrine&lt;/a&gt;, Montrose aims to &lt;a href="http://rubyonrails.org/doctrine/#optimize-for-programmer-happiness"&gt;optimize for programmer happiness&lt;/a&gt;. Hence, there are several ways to define equivalent recurrences. For example, recurrences intervals can be configured as an explicit option, or inferred by the frequency duration.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 3 hours, all equivalent
Montrose.hourly.interval(3)
Montrose.every(3.hours)
Montrose::Recurrence.new(every: :hour, interval: 3)
Montrose::Recurrence.new(every: 3.hours)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Montrose&lt;/code&gt; tries to provide useful feedback when you run into exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r = Montrose.total(1)
r.each { |t| puts t}
Montrose::ConfigurationError: Please specify the :every option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Conceptually, recurrences can represent an infinite sequence. When we say
simply &amp;ldquo;every day&amp;rdquo;, there is no implied ending. It&amp;rsquo;s therefore possible to
create a recurrence that can enumerate forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every day starting now
r = Montrose.daily

# this expression will never complete, Ctrl-c!
r.map(&amp;amp;:to_date)

# so use your `Enumerable` methods wisely
r.lazy.map(&amp;amp;:to_date).select { |d| d.mday &amp;gt; 25 }.take(5).to_a
=&amp;gt; [Fri, 26 Feb 2016,
Sat, 27 Feb 2016,
Sun, 28 Feb 2016,
Mon, 29 Feb 2016,
Sat, 26 Mar 2016]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s straightforward to convert recurrence options back to a hash.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Every 10 minutes starting now
opts = Montrose::Recurrence.new(every: 10.minutes).to_h
=&amp;gt; {:every=&amp;gt;:minute, :interval=&amp;gt;10}

Montrose::Recurrence.new(opts).take(3)
=&amp;gt; [2016-02-03 19:06:07 -0500,
2016-02-03 19:16:07 -0500,
2016-02-03 19:26:07 -0500]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accordingly, &lt;code&gt;Montrose::Recurrence&lt;/code&gt; implements &lt;code&gt;.dump&lt;/code&gt; and &lt;code&gt;.load&lt;/code&gt; so that you can use it with the &lt;code&gt;serialize&lt;/code&gt; feature of &lt;code&gt;ActiveRecord&lt;/code&gt; to back a recurrence by a database column in your Rails apps:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class EventSeries &amp;lt; ActiveRecord::Base
  serialize :recurrence, Montrose::Recurrence
end

es = EventSeries.new(recurrence: Montrose.daily.at(&amp;quot;12pm&amp;quot;))
es.save

es = EventSeries.last
es.recurrence
# =&amp;gt; #&amp;lt;Montrose::Recurrence:...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This library is still in its early stages (version &lt;code&gt;0.2.1&lt;/code&gt; as of this writing) and aspects of the API are still in flux, such as the ability to configure default start and end times or combines multiple, distinct recurrences in a &lt;code&gt;Montrose::Schedule&lt;/code&gt;. &lt;code&gt;Montrose&lt;/code&gt; has one dependency - &lt;code&gt;ActiveSupport&lt;/code&gt; - for time calculations.&lt;/p&gt;

&lt;p&gt;There are &lt;a href="https://github.com/rossta/montrose/issues"&gt;plenty of missing features&lt;/a&gt;, including iCal serialization though Montrose already &lt;a href="https://github.com/rossta/montrose/blob/master/spec/rfc_spec.rb"&gt;supports most of the examples&lt;/a&gt; given by the iCal spec, &lt;a href="https://www.ietf.org/rfc/rfc2445.txt"&gt;rfc2445&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I still haven&amp;rsquo;t built that Edgar clone, but feel this is a good place from which to grow. As I said earlier, the &lt;code&gt;ice_cube&lt;/code&gt; gem is a mature library and already does much of what I&amp;rsquo;ve described here. Writing my own solution allowed me to think more deeply about the internal mechanisms for calculating recurrences and ultimately, once my curiosity was piqued, I couldn&amp;rsquo;t stop. If, you like what &lt;code&gt;Montrose&lt;/code&gt; has to offer and you&amp;rsquo;re feeling adventurous, try it out in your own application and send some feedback. Don&amp;rsquo;t hesitate to &lt;a href="https://github.com/rossta/montrose"&gt;fork the project&lt;/a&gt; and contribute.&lt;/p&gt;

&lt;p&gt;NYC.rb?&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# Second Tuesday of every month
r = Montrose.every(:month, day: { tuesday: [2] }, at: &amp;quot;7pm&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See you there.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How to write a simple web crawler in Ruby - revisited</title>
    <link rel="alternate" href="/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html"/>
    <id>/blog/how-to-write-a-simple-web-crawler-in-ruby-revisited.html</id>
    <published>2016-01-26T19:00:00-05:00</published>
    <updated>2016-01-26T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo.jpg?1455138702"&gt;&lt;/p&gt;

&lt;p&gt;Let’s build a simple web crawler in Ruby. For inspiration, I’d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin’s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We’ll adapt Skork’s original goals and...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Web Crawl" src="/assets/images/blog/stock/spider-web-pexels-photo.jpg?1455138702" /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s build a simple web crawler in Ruby. For inspiration, I&amp;rsquo;d like to
to revisit &lt;a href="http://www.skorks.com/2009/07/how-to-write-a-web-crawler-in-ruby/"&gt;Alan Skorkin&amp;rsquo;s How to Write a Simple Web Crawler in Ruby&lt;/a&gt; and attempt to achieve something similar with a fresh perspective.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll adapt Skork&amp;rsquo;s original goals and provide a few of our own:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;must be able to crawl just a single domain&lt;/li&gt;
&lt;li&gt;must be able to limit number of pages to crawl&lt;/li&gt;
&lt;li&gt;the results should be represented as structured data so we don&amp;rsquo;t have an incomprehensible soup of content&lt;/li&gt;
&lt;li&gt;the results should be enumerable so we can have flexibility in how they&amp;rsquo;re handled&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  Caveats! Please keep in mind that there are, of course, &lt;a href="http://webscraper.io/"&gt;many&lt;/a&gt; &lt;a href="http://scrapy.org/"&gt;resources&lt;/a&gt; for
  using resilient, well-tested &lt;a href="https://www.import.io/"&gt;crawlers&lt;/a&gt; in a variety of languages. We have mere academic intentions
  here so we choose to ignore many important concerns, such as client-side rendering, parallelism, and handling failure, as a matter of convenience.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Breaking it down&lt;/h3&gt;

&lt;p&gt;For this exercise, we&amp;rsquo;re going to crawl &lt;a href="http://www.programmableweb.com/"&gt;Programmable Web&lt;/a&gt; to extract data from their &lt;a href="http://www.programmableweb.com/apis/directory"&gt;API directory&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Rather than take the naive approach of grabbing all content from any page, we&amp;rsquo;re going to build a webcrawler that emits
structured data. Traversing from the first page of the api directory, our
crawler will visit web pages like a nodes of a tree, collecting data and
additional urls along the way.&lt;/p&gt;

&lt;p&gt;Imagine that the results of our web crawl as a nested collection of
hashes with meaningful key-value pairs.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# results
[
  {
    name: &amp;quot;Google Maps&amp;quot;,
    api_provider: &amp;quot;https://google.com&amp;quot;
    api_homepage: &amp;quot;https://developers.google.com/maps/&amp;quot;
    categories: [&amp;quot;Mapping&amp;quot;, &amp;quot;Viewer&amp;quot;],
    provider_formats: [&amp;quot;JSON&amp;quot;, &amp;quot;KML&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
  {
    name: &amp;quot;Twitter&amp;quot;,
    api_provider: &amp;quot;https://twitter.com&amp;quot;
    api_homepage: &amp;quot;https://dev.twitter.com/rest/public&amp;quot;
    categories: [&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;],
    provider_formats: [&amp;quot;Atom&amp;quot;, &amp;quot;JSON&amp;quot;, &amp;quot;REST&amp;quot;, &amp;quot;RSS&amp;quot;, &amp;quot;XML&amp;quot;]
    ...
  },
]
&lt;/code&gt;&lt;/pre&gt;

&lt;aside class="callout panel"&gt;
&lt;p&gt;
  When using a web crawler, be aware of the limitations described in the website&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Robots_exclusion_standard"&gt;robots.txt&lt;/a&gt; file. In this post, we skip automated parsing and detection of &lt;a href="http://www.programmableweb.com/robots.txt"&gt;Programmable Web&amp;rsquo;s robots.txt&lt;/a&gt; to filter out blacklisted urls and set a crawl delay dynamically. If you choose to run this code on your own, please crawl responsibly.
&lt;/p&gt;
&lt;/aside&gt;

&lt;h3&gt;Designing the surface&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve been following my posts lately, you know that &lt;a href="https://rossta.net/blog/ruby-enumerable.html"&gt;I love Enumerable&lt;/a&gt; and you may not be surprised that I&amp;rsquo;d like to model our structured, website data with an &lt;a href="/blog/what-is-enumerator.html"&gt;Enumerator&lt;/a&gt;. This will provide a familiar, flexible interface that can be adapted for logging, storage, transformation, and a wide range of use cases.&lt;/p&gt;

&lt;p&gt;I want to simply ask a &lt;code&gt;spider&lt;/code&gt; object for its results and get back an enumerator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider.results
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll be able to do some interesting things, like stream the
results lazily into a flexible storage engine, e.g. &lt;a href="https://www.mongodb.org/"&gt;mongodb&lt;/a&gt; or &lt;code&gt;PStore&lt;/code&gt;,
available from the &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/pstore/rdoc/PStore.html"&gt;Ruby standard library&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;pstore&amp;quot;
store  = PStore.new(&amp;quot;api_directory.pstore&amp;quot;)

# create `spider`, then ...

spider.results.lazy.take(50).each_with_index do |result, i|
  store.transaction do
    store[result[:name]] = result
    store.commit
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Writing the crawler&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to write a &lt;code&gt;Spider&lt;/code&gt; class to enumerate website data. Our spider implementation borrows heavily from &lt;a href="https://github.com/joeyAghion/spidey"&gt;joeyAghion&amp;rsquo;s spidey&lt;/a&gt; gem, described as a &amp;ldquo;loose framework for crawling and scraping websites&amp;rdquo; and Python&amp;rsquo;s venerable &lt;a href="http://scrapy.org/"&gt;Scrapy&lt;/a&gt; project, which allows you to scrape websites &amp;ldquo;in a fast, simple, yet extensible way.&amp;rdquo; Both resources achieve the goals of being easy-to-use and extensible.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll build our web crawler piece-by-piece, but if you want a full preview of the source, check out it &lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; will maintain a set of urls to visit, data is collects, and a set of url &amp;ldquo;handlers&amp;rdquo; that will describe how each page should be processed. We&amp;rsquo;ll take advantage of one external dependency, &lt;code&gt;mechanize&lt;/code&gt;, to handle interaction with the pages we visit - to extract data, resolve urls, follow redirects, etc. Below is the &lt;code&gt;#enqueue&lt;/code&gt; method to add urls and their handlers to a running list in our spider.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;mechanize&amp;quot; # as of this writing, the latest release is 2.7.4

class Spider
  def enqueue(url, method)
    url = agent.resolve(url).to_s
    return if @handlers[url]
    @urls &amp;lt;&amp;lt; url
    @handlers[url] ||= { method: method, data: {} }
  end

  private

  def agent
    @agent ||= Mechanize.new
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we process each page we&amp;rsquo;ll need a way to record the structured data we extract from various pages. We&amp;rsquo;ll expose a &lt;code&gt;#record&lt;/code&gt; method append a hash of data to the &lt;code&gt;@results&lt;/code&gt; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def record(data = {})
    @results &amp;lt;&amp;lt; data
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our &lt;code&gt;Spider&lt;/code&gt; will only know how to enumerate urls and record data, we&amp;rsquo;ll introduce a collaborator object to contain the implementation for consuming data for a specific site. For now, we&amp;rsquo;ll call this object a &amp;ldquo;processor&amp;rdquo;. The processor will respond to the messages &lt;code&gt;#root&lt;/code&gt; and &lt;code&gt;#handler&lt;/code&gt; - the first url and handler method to enqueue for the spider, respectively. We&amp;rsquo;ll also provide options for enforcing limits on the number of pages to crawl and the delay between each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  REQUEST_INTERVAL = 5
  MAX_URLS = 1000

  def initialize(processor, attrs = {})
    @processor = processor

    @urls     = []
    @results  = []
    @handlers = {}

    @interval = attrs.fetch(:interval, REQUEST_INTERVAL)
    @max_urls = attrs.fetch(:max_urls, MAX_URLS)

    enqueue(processor.root, processor.handler)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Enumerator Two Ways&lt;/h3&gt;

&lt;p&gt;Now for the real meat of our young &lt;code&gt;Spider&lt;/code&gt;. The &lt;code&gt;#results&lt;/code&gt; method is the key public interface: it enumerates the enqueued urls and yields members of the &lt;code&gt;@results&lt;/code&gt; collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Spider
  def results
    return enum_for(:results) unless block_given?

    index = @results.length
    enqueued_urls.each do |url, handler|

      # process url
      @processor.send(handler[:method], agent.get(url), handler[:data])

      if block_given? &amp;amp;&amp;amp; @results.length &amp;gt; index
        yield @results.last
        index += 1
      end

      # crawl delay
      sleep @interval if @interval &amp;gt; 0
    end
  end

  private

  def enqueued_urls
    Enumerator.new do |y|
      index = 0
      while index &amp;lt; @urls.count &amp;amp;&amp;amp; index &amp;lt;= @max_urls
        url = @urls[index]
        index += 1
        next unless url
        y.yield url, @handlers[url]
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting thing to note is that the size of our url queue and the collected results may be growing as we crawl more pages. For the &lt;code&gt;#enqueued_urls&lt;/code&gt; private method, we&amp;rsquo;re using an &lt;code&gt;Enumerator&lt;/code&gt; to wrap the logic for iterating over the list of &lt;code&gt;@urls&lt;/code&gt; and maintaining state, like the &lt;code&gt;index&lt;/code&gt;. The &lt;code&gt;Enumerator&lt;/code&gt; class is well-suited to represent a lazily generated collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def enqueued_urls
  Enumerator.new do |y|
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find it to be a more expressive way to indicate we&amp;rsquo;re enumerating values &amp;ldquo;on demand&amp;rdquo; as opposed to &amp;ldquo;eagerly&amp;rdquo;, like a typical collection.&lt;/p&gt;

&lt;p&gt;Notice we&amp;rsquo;re also returning an enumerator from &lt;code&gt;#results&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def results
  return enum_for(:results) unless block_given?
  # ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique provides the method caller to more flexibility when determining
how to handler the results. While you could pass a block to consume the
results, e.g., &lt;code&gt;spider.results { |r| puts r.inspect }&lt;/code&gt;, this is an eager
operation. We&amp;rsquo;d have to wait for all the pages to be processed before continuing
with the block. Returning an enumerator offers the potential to stream results
to something like a data store.&lt;/p&gt;

&lt;p&gt;Why not include &lt;code&gt;Enumerable&lt;/code&gt; in our &lt;code&gt;Spider&lt;/code&gt; and implement &lt;code&gt;#each&lt;/code&gt; instead? As pointed out in &lt;a href="http://blog.arkency.com/2014/01/ruby-to-enum-for-enumerator/"&gt;Arkency&amp;rsquo;s Stop including Enumerable, return Enumerator
instead&lt;/a&gt;, our
&lt;code&gt;Spider&lt;/code&gt; class doesn&amp;rsquo;t itself represent a collection, so exposing the &lt;code&gt;#results&lt;/code&gt;
method as an enumerator is more appropriate.&lt;/p&gt;

&lt;h3&gt;From Soup to Net Results&lt;/h3&gt;

&lt;p&gt;Our &lt;code&gt;Spider&lt;/code&gt; is now functional so we can move onto the details of extracting data from an actual website.&lt;/p&gt;

&lt;p&gt;Our processor, &lt;code&gt;ProgrammableWeb&lt;/code&gt; will be responsible for wrappin a &lt;code&gt;Spider&lt;/code&gt; instance and extracting data from
the pages it visits. As mentioned previously, our processor will need to
define a root url and initial handler method, for which defaults are provided, and delegate the &lt;code&gt;#results&lt;/code&gt; method to a &lt;code&gt;Spider&lt;/code&gt; instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class ProgrammableWeb
  attr_reader :root, :handler

  def initialize(root: &amp;quot;https://www.programmableweb.com/apis/directory&amp;quot;, handler: :process_index, **options)
    @root = root
    @handler = handler
    @options = options
  end

  def results(&amp;amp;block)
    spider.results(&amp;amp;block)
  end

  private

  def spider
    @spider ||= Spider.new(self, @options)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ProgrammableWeb&lt;/code&gt; will define handler methods that deserialize a web page into additional urls and data to add to our collection of results.
Our spider will invoke the handlers (as seen above with &lt;code&gt;@processor.send(method, agent.get(url), data)&lt;/code&gt;). Each handler method will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def handler_method(page, data = {})
  # enqueue urls and/or record data
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; where &lt;code&gt;page&lt;/code&gt; is an instance of &lt;code&gt;Mechanize::Page&lt;/code&gt; (&lt;a href="http://docs.seattlerb.org/mechanize/Mechanize/Page.html"&gt;docs&lt;/a&gt;) providing a number of methods for interacting with html content:&lt;/p&gt;

&lt;p&gt;The root handler method, &lt;code&gt;ProgrammableWeb#process_index&lt;/code&gt;, will extract api names in the
index list, enqueue api detail pages and additional, paginated indexes. As data
is collected, it may be passed on to handlers further down the tree via
&lt;code&gt;Spider#enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_index(page, data = {})
  page.links_with(href: %r{\?page=\d+}).each do |link|
    spider.enqueue(link.href, :process_index)
  end

  page.links_with(href: %r{/api/\w+$}).each do |link|
    spider.enqueue(link.href, :process_api, name: link.text)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process api detail pages, we&amp;rsquo;ll define a separate handler. Since these pages
will represent &amp;ldquo;leaves&amp;rdquo; in this exercise, we&amp;rsquo;ll merge the data passed in with
that extracted from the page and pass it along to &lt;code&gt;Spider#record&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;def process_api(page, data = {})
  fields = page.search(&amp;quot;#tabs-content .field&amp;quot;).each_with_object({}) do |tag, o|
    key = tag.search(&amp;quot;label&amp;quot;).text.strip.downcase.gsub(%r{[^\w]+}, &amp;#39; &amp;#39;).gsub(%r{\s+}, &amp;quot;_&amp;quot;).to_sym
    val = tag.search(&amp;quot;span&amp;quot;).text
    o[key] = val
  end

  categories = page.search(&amp;quot;article.node-api .tags&amp;quot;).first.text.strip.split(/\s+/)

  spider.record data.merge(fields).merge(categories: categories)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw earlier, recorded data is emitted in the &lt;code&gt;Spider#results&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Now we can make use of our &lt;code&gt;ProgrammableWeb&lt;/code&gt; crawler as intended with simple
instantiation and the ability to enumerate results as a stream of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;spider = ProgrammableWeb.new

spider.results.lazy.take(5).each_with_index do |result, i|
  puts &amp;quot;%-3s: %s&amp;quot; % [i, result.inspect]
end

# 0 : {:name=&amp;gt;&amp;quot;Facebook&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://facebook.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.facebook.com/restserver.php&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.facebook.com/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Webhooks&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, REST&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;http://developers.facebook.com/documentation.php?doc=clients&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.developers.facebook.com/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/fbplatform&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://developers.facebook.com/group.php?gid=2205007948&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developers.facebook.com/tools/explorer&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;API Key, OAuth 2, Username/password&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Webhooks&amp;quot;]}
# 1 : {:name=&amp;gt;&amp;quot;LinkedIn&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.linkedin.com/&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://api.linkedin.com/v1/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developer.linkedin.com/docs&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Enterprise&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;JSON, JSONP, REST, XML&amp;quot;, :other_options=&amp;gt;&amp;quot;JavaScript&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_forum=&amp;gt;&amp;quot;https://developer.linkedin.com/forum&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/linkedindev&amp;quot;, :console_url=&amp;gt;&amp;quot;http://developer.linkedinlabs.com/jsapi-console/#examples/login/simple.html&amp;amp;{&amp;amp;quot;framework&amp;amp;quot;:&amp;amp;quot;platform.linkedin.com/in.js&amp;amp;quot;,&amp;amp;quot;frameworkurl&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;apikey&amp;amp;quot;:&amp;amp;quo&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Enterprise&amp;quot;]}
# 2 : {:name=&amp;gt;&amp;quot;Skype&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://skype.com&amp;quot;, :api_homepage=&amp;gt;&amp;quot;http://www.skype.com/en/developer/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Telephony&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Chat, Messaging, Video, Voice&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Unspecified&amp;quot;, :other_options=&amp;gt;&amp;quot;Skype proprietary&amp;quot;, :ssl_support=&amp;gt;&amp;quot;Yes&amp;quot;, :api_kits=&amp;gt;&amp;quot;https://developer.skype.com/Docs/Web https://developer.skype.com/wiki/Java_API&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://forum.skype.com/index.php?showforum=16&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;Unspecified&amp;quot;, :categories=&amp;gt;[&amp;quot;Telephony&amp;quot;, &amp;quot;Chat,&amp;quot;, &amp;quot;Messaging,&amp;quot;, &amp;quot;Video,&amp;quot;, &amp;quot;Voice&amp;quot;]}
# 3 : {:name=&amp;gt;&amp;quot;Twitter&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://twitter.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://twitter.com/statuses/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://dev.twitter.com/rest/public&amp;quot;, :primary_category=&amp;gt;&amp;quot;Social&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Blogging&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, JSON, REST, RSS, XML&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/twitter-development-talk&amp;quot;, :twitter_url=&amp;gt;&amp;quot;http://twitter.com/twitterapi&amp;quot;, :contact_email=&amp;gt;&amp;quot;api@twitter.com&amp;quot;, :console_url=&amp;gt;&amp;quot;https://dev.twitter.com/console&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth 2, HTTP Basic Auth, OAuth&amp;quot;, :categories=&amp;gt;[&amp;quot;Social&amp;quot;, &amp;quot;Blogging&amp;quot;]}
# 4 : {:name=&amp;gt;&amp;quot;YouTube&amp;quot;, :api_provider=&amp;gt;&amp;quot;http://www.google.com&amp;quot;, :api_endpoint=&amp;gt;&amp;quot;http://gdata.youtube.com/feeds/&amp;quot;, :api_homepage=&amp;gt;&amp;quot;https://developers.google.com/youtube/&amp;quot;, :primary_category=&amp;gt;&amp;quot;Video&amp;quot;, :secondary_categories=&amp;gt;&amp;quot;Media&amp;quot;, :protocol_formats=&amp;gt;&amp;quot;Atom, RSS, JSON, XML, GData&amp;quot;, :other_options=&amp;gt;&amp;quot;Atom Publishing Protocol (Atom/RSS)&amp;quot;, :ssl_support=&amp;gt;&amp;quot;No&amp;quot;, :api_kits=&amp;gt;&amp;quot;Java, PHP Python, Ruby, ActionScript&amp;quot;, :api_forum=&amp;gt;&amp;quot;http://groups.google.com/group/youtube-api/&amp;quot;, :twitter_url=&amp;gt;&amp;quot;https://twitter.com/YouTubeDev/&amp;quot;, :developer_support=&amp;gt;&amp;quot;http://code.google.com/support/bin/topic.py?topic=12357&amp;quot;, :console_url=&amp;gt;&amp;quot;http://code.google.com/apis/ajax/playground/?exp=youtube#simple_embed&amp;quot;, :authentication_mode=&amp;gt;&amp;quot;OAuth2&amp;quot;, :categories=&amp;gt;[&amp;quot;Video&amp;quot;, &amp;quot;Media&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;I admit, it&amp;rsquo;s arguable that this implementation is &amp;ldquo;simple&amp;rdquo;. Skorks provided a straightforward, recursive solution to consume unstructured content. Our approach is iterative and requires some work up front to define which links to consume and how to process them with &amp;ldquo;handlers&amp;rdquo;. However, we were able to achieve an extensible, flexible tool with a nice separation of concerns and a familiar, enumerable interface.&lt;/p&gt;

&lt;p&gt;Modeling results from a multi-level page crawl as a collection may not work for every use case, but, for this exercise, it serves as a nice abstraction. It would now be trivial to take our &lt;code&gt;Spider&lt;/code&gt; class and implement a new processor for a site like &lt;a href="https://rubygems.org"&gt;rubygems.org&lt;/a&gt; or &lt;a href="https://craigslist.org"&gt;craigslist&lt;/a&gt; and stream the results to a database like &lt;a href="http://redis.io"&gt;Redis&lt;/a&gt; or &lt;a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/yaml/rdoc/YAML/Store.html"&gt;&lt;code&gt;YAML::Store&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Try it yourself and let me know what you think of this approach (&lt;a href="https://github.com/rossta/loves-enumerable/blob/master/examples/spider/spider.rb"&gt;full source&lt;/a&gt;).&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>What's new in Ruby 2.3 Enumerable</title>
    <link rel="alternate" href="/blog/whats-new-in-ruby-2-3-enumerable.html"/>
    <id>/blog/whats-new-in-ruby-2-3-enumerable.html</id>
    <published>2016-01-17T19:00:00-05:00</published>
    <updated>2016-01-17T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo.jpg?1455138702"&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We’ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Goodies" src="/assets/images/blog/stock/dark-brown-milk-candy-pexels-photo.jpg?1455138702" /&gt;&lt;/p&gt;

&lt;p&gt;You may have heard &lt;a href="https://www.ruby-lang.org/en/news/2015/12/25/ruby-2-3-0-released/"&gt;Ruby 2.3 dropped&lt;/a&gt; on Christmas this past year. Two new &lt;code&gt;Enumerable&lt;/code&gt; instance methods were added, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt;, both of which are variations on other &lt;code&gt;Enumerable&lt;/code&gt; methods. We&amp;rsquo;ll dissect both here below.&lt;/p&gt;

&lt;h4&gt;Triple Lindey&lt;/h4&gt;

&lt;p&gt;Grep allows you to select members of a collection that match an expression. That expression is &lt;code&gt;some_object === item&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What does &amp;ldquo;triple equals&amp;rdquo; do? Well, in Ruby, as in most languages, that answer is complicated. Since we can define this method however we want in our own classes, it can mean anything. But, most commonly, it is a loose way of asking whether an object belongs to a certain group:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;if &lt;code&gt;a&lt;/code&gt; === &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is a subset of &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A few examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Symbol === :foo     # =&amp;gt; true, :foo is a symbol
String === &amp;quot;foo&amp;quot;    # =&amp;gt; true, &amp;quot;foo&amp;quot; is a string
Symbol === &amp;quot;foo&amp;quot;    # =&amp;gt; false, &amp;quot;foo&amp;quot; is not a symbol
String === :foo     # =&amp;gt; false, :foo is not a string

/foo/ === &amp;quot;foobar&amp;quot;  # =&amp;gt; true, &amp;quot;foobar&amp;quot; matches /foo/
(1..10) === 2       # =&amp;gt; true, 2 is in the range 1..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; use &lt;code&gt;select&lt;/code&gt; to filter out items of a collection with the &lt;code&gt;===&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(20).select { |i| (6..10) === i } # =&amp;gt; [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this is what &lt;code&gt;grep&lt;/code&gt; is for:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep(6..8) # =&amp;gt; [6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So &lt;code&gt;grep&lt;/code&gt; is like saying &amp;ldquo;gimme all the items in the given set&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;To get all the items &lt;em&gt;not&lt;/em&gt; included, use &lt;code&gt;grep_v&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;1.upto(10).grep_v(6..8)
=&amp;gt; [1, 2, 3, 4, 5, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably most likely that you&amp;rsquo;d use &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; with a regular expression, like
to select all the months that end in &amp;ldquo;er&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MONTHS.grep(/er$/)
=&amp;gt; [&amp;quot;September&amp;quot;, &amp;quot;October&amp;quot;, &amp;quot;November&amp;quot;, &amp;quot;December&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Define &lt;code&gt;===&lt;/code&gt; on any class or object to take advantage of filtering with &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;grep_v&lt;/code&gt; in other contexts.&lt;/p&gt;

&lt;h4&gt;Chunking&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Enumerable&lt;/code&gt; module provides several methods for enumerating adjacent
members of a collection, including &lt;code&gt;slice_when&lt;/code&gt;, &lt;code&gt;slice_before&lt;/code&gt;, &lt;code&gt;slice_after&lt;/code&gt;,
&lt;code&gt;each_cons&lt;/code&gt;, and, not surprisingly, &lt;code&gt;chunk&lt;/code&gt;. Ruby 2.3 offers yet another
chunking method, &lt;code&gt;chunk_while&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before diving into &lt;code&gt;chunk_while&lt;/code&gt;, let&amp;rsquo;s look at its relatives, &lt;code&gt;chunk&lt;/code&gt; and &lt;code&gt;slice_when&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the following examples, we&amp;rsquo;ll enumerate over recurring events given by the
&lt;code&gt;Montrose&lt;/code&gt; gem. Montrose provides an api to create recurrences as enumerators.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a recurrence that will enumerate over every other Tuesday at noon.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;quot;montrose&amp;quot;

r = Montrose.every(2.weeks, on: :tuesday, at: &amp;#39;12pm&amp;#39;)

r.take(10).to_a
=&amp;gt; [2016-02-02 12:00:00 -0500,
 2016-02-16 12:00:00 -0500,
 2016-03-01 12:00:00 -0500,
 2016-03-15 12:00:00 -0400,
 2016-03-29 12:00:00 -0400,
 2016-04-12 12:00:00 -0400,
 2016-04-26 12:00:00 -0400,
 2016-05-10 12:00:00 -0400,
 2016-05-24 12:00:00 -0400,
 2016-06-07 12:00:00 -0400]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For calendaring, it may be useful to split this array into chunks by month.&lt;/p&gt;

&lt;p&gt;We could use &lt;code&gt;group_by&lt;/code&gt; to return a hash of month numbers to Tuesday time
instances:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month)
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;chunk&lt;/code&gt; method is similar to &lt;code&gt;group_by&lt;/code&gt; as it will divide the collection
into groups based on the given block/proc except it returns an enumerator
instead of a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month)
=&amp;gt; #&amp;lt;Enumerator: ...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I recently &lt;a href="/blog/what-is-enumerator.html"&gt;described some great things you can do with enumerators in Ruby&lt;/a&gt; including transforming the result of chunk into an array of month, time pairs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk(&amp;amp;:month).to_a
=&amp;gt; [[2, [2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500]],
 [3, [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400]],
 [4, [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400]],
 [5, [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400]],
 [6, [2016-06-07 12:00:00 -0400]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly enough, passing the previous result to &lt;code&gt;Hash[]&lt;/code&gt; returns the same
result we got with &lt;code&gt;group_by&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;Hash[r.take(10).chunk(&amp;amp;:month).to_a]
=&amp;gt; {2=&amp;gt;[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 3=&amp;gt;[2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 4=&amp;gt;[2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 5=&amp;gt;[2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 6=&amp;gt;[2016-06-07 12:00:00 -0400]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we just wanted the groups of times, not the month keys, we could ask for the
&lt;code&gt;group_by&lt;/code&gt; values:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).group_by(&amp;amp;:month).values
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can replace this computation with &lt;code&gt;slice_when&lt;/code&gt; which will allow us to compare
adjacent members to determine &amp;ldquo;when&amp;rdquo; to start a new slice (or chunk). That means
the block we pass to &lt;code&gt;slice_when&lt;/code&gt; accepts two arguments, the current and
previous collection member, and should return true or false. In this
case, we want a new slice to start when the month of the previous time does not
match the month of the current time as we enumerate:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).slice_when { |a, b| a.month != b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the return value of &lt;code&gt;slice_when&lt;/code&gt; is an enumerator like we saw with &lt;code&gt;chunk&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It turns out, the most common use cases of &lt;code&gt;slice_when&lt;/code&gt; tend to be negative
comparisons, i.e., &amp;ldquo;slice when the previous thing is not the same as the current
thing&amp;rdquo;. Since this is Ruby after all, wouldn&amp;rsquo;t you prefer to stay positive?&lt;/p&gt;

&lt;p&gt;Which brings us to &lt;code&gt;chunk_while&lt;/code&gt;. Ruby 2.3 introduces this positive complement to
&lt;code&gt;slice_when&lt;/code&gt; so we can say, &amp;ldquo;keep the same chunk if the current thing &lt;em&gt;does&lt;/em&gt;
match the previous thing&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Back to our Tuesday recurrences. Let&amp;rsquo;s replace &lt;code&gt;slice_when&lt;/code&gt; with &lt;code&gt;chunk_while&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;r.take(10).chunk_while { |a, b| a.month == b.month }.to_a
=&amp;gt; [[2016-02-02 12:00:00 -0500, 2016-02-16 12:00:00 -0500],
 [2016-03-01 12:00:00 -0500, 2016-03-15 12:00:00 -0400, 2016-03-29 12:00:00 -0400],
 [2016-04-12 12:00:00 -0400, 2016-04-26 12:00:00 -0400],
 [2016-05-10 12:00:00 -0400, 2016-05-24 12:00:00 -0400],
 [2016-06-07 12:00:00 -0400]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in short, &lt;code&gt;Enumerable&lt;/code&gt; in Ruby 2.3 gives us both a negative and a positive variation, &lt;code&gt;grep_v&lt;/code&gt; and &lt;code&gt;chunk_while&lt;/code&gt; respectively, on existing methods.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Looking for a way to handle recurring events in your app? Be sure to check out &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Debugging SystemStackError</title>
    <link rel="alternate" href="/blog/debugging-systemstackerror.html"/>
    <id>/blog/debugging-systemstackerror.html</id>
    <published>2016-01-11T19:00:00-05:00</published>
    <updated>2016-01-11T19:00:00-05:00</updated>
    <author>
      <name>Ross Kaffenberger</name>
    </author>
    <summary type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo.jpg?1455138702"&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words,...&lt;/p&gt;</summary>
    <content type="html">&lt;p&gt;&lt;img alt="Get it? Stack? Logs?" src="/assets/images/blog/stock/logs-pexels-photo.jpg?1455138702" /&gt;&lt;/p&gt;

&lt;p&gt;Arrgggh. Ever come across this in your Ruby app?&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;SystemStackError: stack level too deep
    /Users/ross/dev/rossta/montrose/lib/montrose/options.rb:204
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;SystemStackError&lt;/code&gt; occurs when your Ruby code encounters a stack overflow; in
other words, the memory allocated to execute the program exceeded the memory
available on the stack.&lt;/p&gt;

&lt;p&gt;The most common cause of a stack overflow in application code that
recursively calls itself without terminating arguments: an infinite loop in your
code.&lt;/p&gt;

&lt;p&gt;You can reproduce such an error with code like this in a terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ pry --noprompt
def foo
  foo
end
=&amp;gt; :foo
foo
SystemStackError: stack level too deep
from /Users/ross/.gem/ruby/2.1.6/gems/pry-0.10.3/lib/pry/pry_instance.rb:355
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: for the examples in this post, assume I&amp;rsquo;m using Ruby 2.1 unless otherwise
indicated.&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;$ ruby -v
ruby 2.1.6p336 (2015-04-13 revision 50298) [x86_64-darwin14.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prior to Ruby 2.2 and &lt;a href="https://bugs.ruby-lang.org/issues/6216"&gt;this issue&lt;/a&gt;, the
backtrace for &lt;code&gt;SystemStackError&lt;/code&gt; was reduced to one line. That meant, unless
that one line lead you to an obvious culprit in your source code, it
would be very difficult to unravel the method calls causing the stack to overflow.&lt;/p&gt;

&lt;p&gt;So, first step in debugging the &lt;code&gt;SystemStackError&lt;/code&gt; is upgrade to Ruby 2.2!&lt;/p&gt;

&lt;p&gt;In case that&amp;rsquo;s not possible, there&amp;rsquo;s still hope. Let&amp;rsquo;s try using information
from the error first. Here&amp;rsquo;s the method containing &lt;a href="https://github.com/rossta/montrose/blob/e5b7a12f6832b4f971a52b27800cefe144ecd399/lib/montrose/options.rb#L204"&gt;the line in the backtrace&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# lib/montrose/options.rb:204

def map_arg(arg, &amp;amp;block)
  return nil unless arg

  Array(arg).map(&amp;amp;block)    # line 204
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No obvious culprit. This method doesn&amp;rsquo;t call itself and there are multiple callers
of this method in this class.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try rescuing from the error in a test and printing the execution stack
using &lt;a href="http://ruby-doc.org/core-2.2.3/Kernel.html#method-i-caller"&gt;&lt;code&gt;Kernel.caller&lt;/code&gt;&lt;/a&gt;. I can isolate the application code that produces the stack overflow in a single test and rescue there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;it &amp;quot;a test&amp;quot; do
  # given

  begin
    # when
  rescue SystemStackError
    puts caller
  end

  # then
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what I get:&lt;/p&gt;

&lt;pre&gt;&lt;code class="bash"&gt;$ bin/m spec/rfc_spec.rb:426
/Users/ross/dev/rossta/montrose/spec/rfc_spec.rb:434:in `block (2 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:108:in `block (3 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:205:in `capture_exceptions&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:105:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:256:in `time_it&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:104:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:276:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest/test.rb:103:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:781:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:308:in `run_one_method&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:296:in `block (2 levels) in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `each&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:295:in `block in run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:334:in `on_signal&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:321:in `with_info_handler&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:294:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `block in __run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `map&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:155:in `__run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/minitest-5.8.3/lib/minitest.rb:129:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runners/minitest_5.rb:9:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/executor.rb:26:in `execute&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m/runner.rb:17:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/lib/m.rb:13:in `run&amp;#39;
/Users/ross/.gem/ruby/2.1.6/gems/m-1.4.2/bin/m:4:in `&amp;lt;top (required)&amp;gt;&amp;#39;
bin/m:16:in `load&amp;#39;
bin/m:16:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backtrace points to lines in minitest. Since I&amp;rsquo;ve been running tests prior
to this isssue successfully, it&amp;rsquo;s unlikely minitest is the source of the stack overflow error. So rescuing from &lt;code&gt;SytemStackError&lt;/code&gt; doesn&amp;rsquo;t help us either.&lt;/p&gt;

&lt;p&gt;Luckily, we have &lt;a href="https://gist.github.com/jbgo/4493822"&gt;this gist&lt;/a&gt; from
&lt;a href="https://github.com/jbgo"&gt;@jbgo&lt;/a&gt; who highlighted a special feature in Ruby for
tracing function events: &lt;a href="http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-set_trace_func"&gt;&lt;code&gt;Kernel.set_trace_func&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the example from the docs:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class Test
  def test
    a = 1
    b = 2
  end
end

set_trace_func proc { |event, file, line, id, binding, classname|
  printf &amp;quot;%8s %s:%-2d %10s %8s\n&amp;quot;, event, file, line, id, classname
}
t = Test.new
t.test

    line prog.rb:11               false
  c-call prog.rb:11        new    Class
  c-call prog.rb:11 initialize   Object
c-return prog.rb:11 initialize   Object
c-return prog.rb:11        new    Class
    line prog.rb:12               false
    call prog.rb:2        test     Test
    line prog.rb:3        test     Test
    line prog.rb:4        test     Test
  return prog.rb:4        test     Test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method &lt;code&gt;set_trace_func&lt;/code&gt; sets a global proc to be invoked in response to
runtime events including the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c-call&lt;/code&gt; a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-return&lt;/code&gt; return from a C-language routine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call&lt;/code&gt; a Ruby method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; start a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;end&lt;/code&gt; finish a class or module definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt; execute code on a new line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raise&lt;/code&gt; raise an exception&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt; return from a Ruby method&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we want to isolate the Ruby method causing the infinite loop in our stack,
we&amp;rsquo;ll log the line info for &lt;code&gt;call&lt;/code&gt; events:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/spec_helper.rb

$trace_out = open(&amp;quot;trace.txt&amp;quot;)

set_trace_func proc { |event, file, line, id, binding, classname|
  if event == &amp;#39;call&amp;#39;
    $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-running the test produces a &lt;code&gt;trace.txt&lt;/code&gt; file that records all the Ruby method
calls encountered during execution. Inspecting this log, we hope to find a
repeating pattern of an identical list of method calls.&lt;/p&gt;

&lt;p&gt;In my case, the start of each pattern pointed to another line in my source where
the stack originates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
/Users/ross/dev/rossta/montrose/lib/montrose/stack.rb:38 Montrose::Stack#advance
/Users/ross/dev/rossta/montrose/lib/montrose/frequency/yearly.rb:4 Montrose::Frequency::Yearly#include?
/Users/ross/dev/rossta/montrose/lib/montrose/frequency.rb:51 Montrose::Frequency#matches_interval?
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A useful trick is to keep the trace routine in a separate file that you can
incorporate with an environment variable. You can also leverage &lt;code&gt;Kernel.caller&lt;/code&gt;
here and only log when the stack exceeds an arbitrarily large size.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# spec/support/trace.rb

if ENV[&amp;quot;TRACE&amp;quot;]
  $stack_size = ENV[&amp;quot;TRACE&amp;quot;].to_i
  $trace_out = open(&amp;quot;trace.txt&amp;quot;)

  set_trace_func proc { |event, file, line, id, binding, classname|
    if event == &amp;#39;call&amp;#39; &amp;amp;&amp;amp; caller.length &amp;gt; $stack_size
      $trace_out.puts &amp;quot;#{file}:#{line} #{classname}##{id}&amp;quot;
    end
  }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my &lt;a href="https://github.com/rossta/montrose"&gt;Montrose&lt;/a&gt; gem, &lt;a href="https://github.com/rossta/montrose/blob/9600e0b63bde342011b3b9b1e29ab9f76f5f69c3/spec/support/trace.rb"&gt;this file&lt;/a&gt; gets loaded during every test run but the &lt;code&gt;set_trace_func&lt;/code&gt; hook will
only be evaluated when the &lt;code&gt;TRACE&lt;/code&gt; environment variable is present:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ TRACE=500 bin/m spec/montrose/recurrence_spec.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, you won&amp;rsquo;t need to resort to this workaround for &lt;code&gt;SystemStackError&lt;/code&gt; in Ruby
2.2+, but keep this in mind next time you get stuck &amp;ldquo;in the loop&amp;rdquo;.&lt;/p&gt;
</content>
  </entry>
</feed>
